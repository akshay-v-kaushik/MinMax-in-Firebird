/*
 *	PROGRAM:	Interactive SQL utility
 *	MODULE:		show.epp
 *	DESCRIPTION:	Display routines
 *
 * The contents of this file are subject to the Interbase Public
 * License Version 1.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy
 * of the License at http://www.Inprise.com/IPL.html
 *
 * Software distributed under the License is distributed on an
 * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * The Original Code was created by Inprise Corporation
 * and its predecessors. Portions created by Inprise Corporation are
 * Copyright (C) Inprise Corporation.
 *
 * All Rights Reserved.
 * Contributor(s): ______________________________________.
 * Revision 1.2  2000/11/19 07:02:49  fsg
 * Change in show.epp to use CHARACTER_LENGTH instead of FIELD_LENGTH in
 * SHOW PROCEDURE
 *
 * 19-May-2001 Claudio Valderrama.
 * Change to be in sync with extract.e: BLOB is not returned
 * by value but by descriptor.
 * 2001.09.21 Claudio Valderrama: Show correct mechanism for UDF parameters.
 * 2001.10.01 Claudio Valderrama: SHOW GRANTS works without any argument, too.
 *   Metadata extraction is slightly faster if SHOW_grants() knows the obj_type.
 *   Keyword USER is written when the grantee is a user and since the engine
 *   now supports GRANT...to ROLE role_name, ROLE is written when the grantee is
 *   indeed a role. When the grantee is a group, it's shown, too.
 * 2003.02.04 Dmitry Yemanov: support for universal triggers
 */

#include "firebird.h"
#include <stdio.h>
#include "../jrd/license.h"
#include <string.h>

#include "../yvalve/gds_proto.h"
#include "ibase.h"
#include "../isql/isql.h"
#include "../jrd/intl.h"
#include "../common/intlobj_new.h"
#include "../common/StdHelper.h"
#include "../common/classes/AlignedBuffer.h"
#include "../common/classes/ClumpletReader.h"
#include "../isql/isql_proto.h"
#include "../isql/show_proto.h"
#include "../isql/iutils_proto.h"
#include "../jrd/obj.h"
#include "../jrd/ods.h"
#include "../isql/extra_proto.h"
#include "../common/utils_proto.h"
#include "../jrd/constants.h"
#include "../common/classes/UserBlob.h"
#include "../common/classes/VaryStr.h"
#include "../common/classes/ImplementHelper.h"
#include "../common/classes/MetaString.h"
#include "../common/TimeZoneUtil.h"
#include "../isql/OptionsBase.h"

#include <firebird/Interface.h>

#ifdef HAVE_CTYPE_H
#include <ctype.h>
#endif

using namespace Firebird;
using MsgFormat::SafeArg;


//DATABASE DB = EXTERN COMPILETIME "yachts.lnk";
DATABASE DB = EXTERN COMPILETIME "yachts.lnk" RUNTIME isqlGlob.global_Db_name;


// This enumeration tell comment-related routines how to behave: for SHOW,
// we present names and text as they are. For EXTRACT, we need to make a valid
// script and escape double quotes in identifiers and single quotes in strings.
enum commentMode {cmmShow, cmmExtract};


static void make_priv_string(USHORT, char*, bool);
static processing_state show_all_tables(SSHORT);
static void show_charsets(SSHORT char_set_id, SSHORT collation);
static processing_state show_check(const SCHAR*);
static processing_state show_collations(const SCHAR*, SSHORT sys_flag, const char* msg = 0, bool compact = false);
static void show_comment(const char* objtype, char* packageName, char* name1, char* name2,
	ISC_QUAD* blobfld, const commentMode showextract, const char* banner);
static processing_state show_comments(const commentMode showextract, const char* banner);
static void show_db();
static processing_state show_dependencies(const char* object);
static processing_state show_dependencies(const char* object, int obj_type);
static processing_state show_dialect();
static processing_state show_domains(const SCHAR*);
static processing_state show_exceptions(const SCHAR*);
static processing_state show_filters(const SCHAR*);
static processing_state show_functions(
	const char* funcname, const char* packname, bool quoted, bool system, const char* msg = nullptr);
static processing_state show_func_legacy(const MetaString&);
static processing_state show_func(const MetaString&, const MetaString&);
static processing_state show_generators(const SCHAR*);
static void show_index(SCHAR*, SCHAR*, const SSHORT, const SSHORT, const SSHORT);
static processing_state show_indices(const char*);
static processing_state show_proc(const char*, const char*, bool, bool, const char* msg = nullptr);
static processing_state show_packages(const SCHAR* package_name, bool, const SCHAR* = NULL);
static processing_state show_publications(const SCHAR* pub_name, bool, const SCHAR* = NULL);
static void show_pub_table(const SCHAR* table_name);
static processing_state show_role(const SCHAR*, bool, const char* msg = NULL);
static processing_state show_secclass(const std::optional<MetaString>& object, bool detail);
static processing_state show_table(const SCHAR*, bool);
static processing_state show_trigger(const SCHAR*, bool, bool);
static processing_state show_users();
static processing_state show_users12();
static processing_state show_wireStats();

const char* const spaces = "                                ";
static TEXT Print_buffer[512];
static TEXT SQL_identifier[BUFFER_LENGTH256];
static bool reReadDbOwner = true;


namespace {

// Used to make sure that local calls to print stuff go to isqlGlob.Out
// and not to stdout if IUtil::version gets called

class VersionCallback :
	public Firebird::AutoIface<Firebird::IVersionCallbackImpl<VersionCallback, Firebird::CheckStatusWrapper> >
{
public:
	// IVersionCallback implementation
	void callback(Firebird::CheckStatusWrapper*, const char* text)
	{
		isqlGlob.printf("%s%s", text, NEWLINE);
	}
};

} // anonymous namespace


static SINT64 ISQL_vax_integer(const UCHAR* bytes, USHORT length)
{
	return isc_portable_integer(bytes, length);
}


// Initialize types

// Keep this array in sync with obj.h in jrd.
static const SCHAR* Object_types[] =
{
	"Table",
	"View",
	"Trigger",
	"Computed column",
	"Validation",
	"Procedure",
	"Expression index",
	"Exception",
	"User",
	"Domain",
	"Index",
	"Count [error if used]",
	"User group",
	"SQL role",
	"Generator",
	"User defined function",
	"Blob filter",	// impossible to have explicit dependencies on it, but...
	"Collation"
};



const SCHAR* Trigger_prefix_types[] =
{
	"BEFORE",			// keyword
	"AFTER"				// keyword
};

const SCHAR* Trigger_suffix_types[] =
{
	"",
	"INSERT",			// keyword
	"UPDATE",			// keyword
	"DELETE"			// keyword
};

const SCHAR* Db_trigger_types[] =
{
	"CONNECT",				// keyword
	"DISCONNECT",			// keyword
	"TRANSACTION START",	// keyword
	"TRANSACTION COMMIT",	// keyword
	"TRANSACTION ROLLBACK"	// keyword
};


enum priv_flag {
	priv_UNKNOWN	= 1,
	priv_SELECT	= 2,
	priv_INSERT	= 4,
	priv_UPDATE	= 8,
	priv_DELETE	= 16,
	priv_EXECUTE	= 32,
	priv_REFERENCES	= 64,
	priv_CREATE = 128,
	priv_ALTER = 256,
	priv_DROP = 512
};


static const struct
{
	USHORT priv_flag;
	const char* priv_string;
} privs[] =
{
	{ priv_DELETE, "DELETE"},			// keyword
	{ priv_EXECUTE, "EXECUTE"},			// keyword
	{ priv_INSERT, "INSERT"},			// keyword
	{ priv_SELECT, "SELECT"},			// keyword
	{ priv_UPDATE, "UPDATE"},			// keyword
	{ priv_REFERENCES, "REFERENCES"},	// keyword
	{ priv_CREATE, "CREATE"},			// keyword
	{ priv_ALTER, "ALTER"},				// keyword
	{ priv_DROP, "DROP"},				// keyword
	{ 0, NULL}
};

// strlen of each element above, + strlen(", ") for separators

const int MAX_PRIV_LIST = (6 + 2 + 7 + 2 + 6 + 2 + 6 + 2 + 6 + 2 + 10 + 2 + 6 + 2 + 5 + 2 + 4 + 1);

const int PRIV_UPDATE_POS = 4;
const int PRIV_REFERENCES_POS = 5;

const int RELATION_PRIV_ALL = priv_SELECT | priv_INSERT | priv_UPDATE | priv_DELETE | priv_REFERENCES;

struct PrivilegeFields
{
	const char* privilege;
	string fields;
};

// Added support to display FORCED WRITES status. - PR 27-NOV-2001
// Added support to display transaction info when next_transaction id is fixed.
// Added support to display ODS version. CVC 26-Aug-2004.
static const UCHAR db_items[] =
{
	isc_info_page_size,
	isc_info_db_size_in_pages,
	fb_info_pages_used,
	fb_info_pages_free,
	isc_info_sweep_interval,
	isc_info_limbo,
	isc_info_forced_writes,
	isc_info_oldest_transaction,
	isc_info_oldest_active,
	isc_info_oldest_snapshot,
	isc_info_next_transaction,
	isc_info_ods_version,
	isc_info_ods_minor_version,
#ifdef DEV_BUILD
	isc_info_db_id,
#endif
	fb_info_crypt_state,
	fb_info_protocol_version,
	fb_info_wire_crypt,
	fb_info_creation_timestamp_tz,
	isc_info_creation_date,
	fb_info_replica_mode,
	isc_info_end
};


/* BPB to force transliteration of any shown system blobs from
 * Database character set (CS_METADATA) to process character set
 * (CS_dynamic).
 * This same BPB is safe to use for both V3 & V4 db's - as
 * a V3 db will ignore the source_ & target_interp values.
 */
static const UCHAR metadata_text_bpb[] =
{
	isc_bpb_version1,
	isc_bpb_source_type, 1, isc_blob_text,
	isc_bpb_target_type, 1, isc_blob_text,
	isc_bpb_source_interp, 1, CS_METADATA,
	isc_bpb_target_interp, 1, CS_dynamic
};

// trigger action helpers

inline int TRIGGER_ACTION_PREFIX(int value)
{
	return (value + 1) & 1;
}

inline int TRIGGER_ACTION_SUFFIX(int value, int slot)
{
	return ((value + 1) >> (slot * 2 - 1)) & 3;
}

const string SHOW_trigger_action(SINT64 type)
{
	switch (type & TRIGGER_TYPE_MASK)
	{
	case TRIGGER_TYPE_DML:
		{
			char buffer[256];
			int prefix = TRIGGER_ACTION_PREFIX(type);
			strcpy(buffer, Trigger_prefix_types[prefix]);
			int suffix = TRIGGER_ACTION_SUFFIX(type, 1);
			strcat(buffer, " ");
			strcat(buffer, Trigger_suffix_types[suffix]);
			if ( (suffix = TRIGGER_ACTION_SUFFIX(type, 2)) )
			{
				strcat(buffer, " OR ");
				strcat(buffer, Trigger_suffix_types[suffix]);
			}
			if ( (suffix = TRIGGER_ACTION_SUFFIX(type, 3)) )
			{
				strcat(buffer, " OR ");
				strcat(buffer, Trigger_suffix_types[suffix]);
			}
			return buffer;
		}

	case TRIGGER_TYPE_DB:
		return string("ON ") + Db_trigger_types[type & ~TRIGGER_TYPE_DB];

	case TRIGGER_TYPE_DDL:
		{
			bool first = true;
			string buffer = Trigger_prefix_types[type & 1];

			if ((type & DDL_TRIGGER_ANY) == DDL_TRIGGER_ANY)
				buffer += " ANY DDL STATEMENT";
			else
			{
				for (SINT64 pos = 1; pos < 64; ++pos)
				{
					if (((1LL << pos) & TRIGGER_TYPE_MASK) || (type & (1LL << pos)) == 0)
						continue;

					if (first)
						first = false;
					else
						buffer += " OR";

					buffer += " ";

					if (pos < FB_NELEM(DDL_TRIGGER_ACTION_NAMES))
					{
						buffer += string(DDL_TRIGGER_ACTION_NAMES[pos][0]) + " " +
							DDL_TRIGGER_ACTION_NAMES[pos][1];
					}
					else
						buffer += "<unknown>";
				}
			}

			return buffer;
		}

	default:
		fb_assert(false);
		return "";
	}
}


// *************************
// S H O W _ c o m m e n t s
// *************************
// Extract database comments. Since it's called by the script extraction
// routine, it does nothing for ODS < 11, unless the force option is true.
void SHOW_comments(bool force)
{
	if (isqlGlob.major_ods >= ODS_VERSION11 || force)
	{
		char banner[BUFFER_LENGTH128];
		fb_utils::snprintf(banner, sizeof(banner), "%s/* Comments for database objects. */%s", NEWLINE, NEWLINE);
		show_comments(cmmExtract, banner);
	}
}


void SHOW_dbb_parameters(Firebird::IAttachment* db_handle,
						 const UCHAR* db_itemsL,
						 unsigned item_length,
						 bool translate,
						 const char* separator)
{
/**************************************
 *
 *	S H O W _ d b b _ p a r a m e t e r s
 *
 **************************************
 *
 * Functional description
 *	Show db_info on this database
 *
 *	Arguments:
 *	    db_handle -- database handle
 *	    db_itemsL -- list of db_info items to process
 *
 **************************************/
	UCHAR buffer[BUFFER_LENGTH400];
	TEXT msg[MSG_LENGTH];

	Firebird::AutoPtr<Firebird::IStatus, Firebird::SimpleDispose>
		status_vector(fbMaster->getStatus());
	Firebird::CheckStatusWrapper statusWrapper(status_vector);
	db_handle->getInfo(&statusWrapper, item_length, db_itemsL, sizeof(buffer), buffer);
	if (ISQL_errmsg(status_vector))
		return;

	bool crdatePrinted = false;

	for (Firebird::ClumpletReader p(Firebird::ClumpletReader::InfoResponse, buffer, sizeof(buffer)); !p.isEof(); p.moveNext())
	{
		UCHAR item = p.getClumpTag();
		SINT64 value_out = 0;

		/*
		 * This is not the best solution but it fixes the lack of <LF> characters
		 * in Windows ISQL.  This will need to remain until we modify the messages
		 * to remove the '\n' (on the PC its '\n\r').
		 * CVC: WISQL is dead. I've restored the missing newlines for isql.
		 */
		switch (item)
		{
		case isc_info_end:
			break;

		case isc_info_page_size:
			value_out = p.getInt();
			isqlGlob.printf("PAGE_SIZE %" SQUADFORMAT"%s", value_out, separator);
			break;

		case isc_info_db_size_in_pages:
			value_out = p.getInt();
			if (translate)
			{
				IUTILS_msg_get(NUMBER_PAGES, msg, SafeArg() << value_out);
				isqlGlob.printf("%s%s", msg, separator);
			}
			else
				isqlGlob.printf("Number of DB pages allocated = %" SQUADFORMAT"%s", value_out, separator);
			break;

		case fb_info_pages_used:
			value_out = p.getInt();
			if (translate)
			{
				IUTILS_msg_get(NUMBER_USED_PAGES, msg, SafeArg() << value_out);
				isqlGlob.printf("%s%s", msg, separator);
			}
			else
				isqlGlob.printf("Number of DB pages used = %" SQUADFORMAT"%s", value_out, separator);
			break;

		case fb_info_pages_free:
			value_out = p.getInt();
			if (translate)
			{
				IUTILS_msg_get(NUMBER_FREE_PAGES, msg, SafeArg() << value_out);
				isqlGlob.printf("%s%s", msg, separator);
			}
			else
				isqlGlob.printf("Number of DB pages free = %" SQUADFORMAT"%s", value_out, separator);
			break;

		case fb_info_crypt_state:
			value_out = p.getInt();
			if (translate)
			{
				Firebird::string s;
				if (value_out & fb_info_crypt_encrypted)
					IUTILS_msg_get(DATABASE_CRYPTED, msg);
				else
					IUTILS_msg_get(DATABASE_NOT_CRYPTED, msg);

				s = msg;

				if (value_out & fb_info_crypt_process)
				{
					s += ", ";
					IUTILS_msg_get(DATABASE_CRYPT_PROCESS, msg);
					s += msg;
				}

				isqlGlob.printf("%s%s", s.c_str(), separator);
			}
			else
			{
				isqlGlob.printf("DB %sencrypted%s%s",
					(value_out & fb_info_crypt_encrypted ? "" : "not "),
					(value_out & fb_info_crypt_process ? ", crypt thread not complete" : ""),
					separator);
			}
			break;

		case isc_info_sweep_interval:
			value_out = p.getInt();
			if (translate)
			{
				IUTILS_msg_get(SWEEP_INTERV, msg, SafeArg() << value_out);
				isqlGlob.printf("%s%s", msg, separator);
			}
			else
				isqlGlob.printf("Sweep interval = %" SQUADFORMAT"%s", value_out, separator);
			break;

		case isc_info_forced_writes:
			value_out = p.getInt();
			isqlGlob.printf("Forced Writes are %s%s", (value_out == 1 ? "ON" : "OFF"), separator);
			break;

		case isc_info_oldest_transaction :
			value_out = p.getInt();
			isqlGlob.printf("Transaction - oldest = %" SQUADFORMAT"%s", value_out, separator);
			break;

		case isc_info_oldest_active :
			value_out = p.getInt();
			isqlGlob.printf("Transaction - oldest active = %" SQUADFORMAT"%s", value_out, separator);
			break;

		case isc_info_oldest_snapshot :
			value_out = p.getInt();
			isqlGlob.printf("Transaction - oldest snapshot = %" SQUADFORMAT"%s", value_out, separator);
			break;

		case isc_info_next_transaction :
			value_out = p.getInt();
			isqlGlob.printf("Transaction - Next = %" SQUADFORMAT"%s", value_out, separator);
			break;

		case isc_info_base_level:
			value_out = p.getInt();
			if (translate)
			{
				IUTILS_msg_get(BASE_LEVEL, msg, SafeArg() << value_out);
				isqlGlob.printf("%s%s", msg, separator);
			}
			else
				isqlGlob.printf("Base level = %" SQUADFORMAT"%s", value_out, separator);
			break;

		case isc_info_limbo:
			value_out = p.getInt();
			if (translate)
			{
				IUTILS_msg_get(LIMBO, msg, SafeArg() << value_out);
				isqlGlob.printf("%s%s", msg, separator);
			}
			else
				isqlGlob.printf("Transaction in limbo = %" SQUADFORMAT"%s", value_out, separator);
			break;

		case isc_info_ods_version:
			isqlGlob.major_ods = p.getInt();
			break;
		case isc_info_ods_minor_version:
			value_out = p.getInt();
			isqlGlob.printf("ODS = %" SLONGFORMAT".%" SQUADFORMAT"%s",
					(SLONG) isqlGlob.major_ods, value_out, separator);
			break;

		case fb_info_wire_crypt:
			if (p.getClumpLength())
				isqlGlob.printf("Wire crypt plugin: %.*s%s", p.getClumpLength(), p.getBytes(), separator);
			break;

		case fb_info_protocol_version:
			value_out = p.getInt();
			if (value_out)
				isqlGlob.printf("Protocol version = %" SQUADFORMAT"%s", value_out, separator);
			else
				isqlGlob.printf("Embedded connection%s", separator);
			break;

		case isc_info_creation_date:
			if (p.getClumpLength() == sizeof(ISC_TIMESTAMP) && !crdatePrinted)
			{
				ISC_TIMESTAMP ts;

				const UCHAR* t = p.getBytes();
				ts.timestamp_date = ISQL_vax_integer(t, sizeof(ISC_DATE));
				t += sizeof(ISC_DATE);
				ts.timestamp_time = ISQL_vax_integer(t, sizeof(ISC_TIME));

				struct tm time;
				isc_decode_timestamp(&ts, &time);

				isqlGlob.printf("Creation date: %s %d, %d %d:%02d:%02d%s",
					FB_SHORT_MONTHS[time.tm_mon], time.tm_mday, time.tm_year + 1900,
					time.tm_hour, time.tm_min, time.tm_sec, separator);
			}
			break;

		case fb_info_creation_timestamp_tz:
			if (p.getClumpLength() == sizeof(ISC_TIMESTAMP))
			{
				ISC_TIMESTAMP_TZ tsz;

				const UCHAR* t = p.getBytes();
				tsz.utc_timestamp.timestamp_date = ISQL_vax_integer(t, sizeof(ISC_DATE));
				t += sizeof(ISC_DATE);
				tsz.utc_timestamp.timestamp_time = ISQL_vax_integer(t, sizeof(ISC_TIME));
				t += sizeof(ISC_TIME);
				tsz.time_zone = ISQL_vax_integer(t, sizeof(ULONG));

				unsigned year, month, day, hours, minutes, seconds, fractions;
				char timeZone[Firebird::TimeZoneUtil::MAX_SIZE];

				Firebird::UtilInterfacePtr()->decodeTimeStampTz(fbStatus, &tsz,
					&year, &month, &day, &hours, &minutes, &seconds, &fractions, sizeof(timeZone), timeZone);

				if (ISQL_errmsg(fbStatus))
					break;

				isqlGlob.printf("Creation date: %s %d, %d %d:%02d:%02d %s%s",
					FB_SHORT_MONTHS[month - 1], day, year,
					hours, minutes, seconds, timeZone, separator);

				crdatePrinted = true;
			}
			break;

#ifdef DEV_BUILD
		case isc_info_db_id:
			{
				// Will print with garbage for now.
				//It's sprintf(info, "DB/Host = %.*s", length, d);
				const UCHAR* s = p.getBytes();
				const UCHAR* end = s + p.getClumpLength();
				++s; // Skip useless indicator.
				int len = *s++;
				isqlGlob.printf("DB = %.*s\n", len, s);
				s += len;
				while (s < end)
				{
					len = *s++;
					isqlGlob.printf("Host = %.*s\n", len, s);
					s += len;
				}
			}
			break;
#endif

		case fb_info_replica_mode:
			{
				value_out = p.getInt();
				const char* mode =
					(value_out == fb_info_replica_none) ? "NONE" :
					(value_out == fb_info_replica_read_only) ? "READ_ONLY" :
					(value_out == fb_info_replica_read_write) ? "READ_WRITE" :
					"unknown";
				isqlGlob.printf("Replica mode: %s%s", mode, separator);
			}
			break;

		case isc_info_truncated:
			return;
		}
	}
}


processing_state SHOW_grants(const SCHAR* object, const SCHAR* terminator, ObjectType obj_type)
{
/**************************************
 *
 *	S H O W _ g r a n t s
 *
 **************************************
 *
 * Functional description
 *	Placeholder for SHOW_grants2 without additional message.
 *
 **************************************/
	return SHOW_grants2 (object, terminator, obj_type, NULL, false);
}


void SHOW_read_owner()
{
/**************************************
 *
 *	S H O W _ r e a d _ o w n e r
 *
 **************************************
 *
 * Functional description
 *	Make granted_by() re-read db owner name.
 *
 **************************************/
	reReadDbOwner = true;
}


static const char* granted_by(char* buffer, const char* grantor, bool nullGrantor)
{
/**************************************
 *
 *	g r a n t e d _ b y
 *
 **************************************
 *
 * Functional description
 *	Output message only if not granted by DB owner.
 *
 **************************************/
	static BASED_ON RDB$RELATIONS.RDB$OWNER_NAME owner;

	if (reReadDbOwner)
	{
		// Get the owner name
		strcpy(owner, DBA_USER_NAME);

		FOR REL IN RDB$RELATIONS WITH
			REL.RDB$RELATION_NAME = "RDB$DATABASE"

			if (!REL.RDB$OWNER_NAME.NULL)
				strcpy(owner, REL.RDB$OWNER_NAME);
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			buffer[0] = '\0';
			return "";
		END_ERROR;

		fb_utils::exact_name(owner);
		reReadDbOwner = false;
	}

 	strcpy(buffer, grantor);
	fb_utils::exact_name(buffer);
	if ((!strcmp(buffer, owner)) || nullGrantor)
		buffer[0] = '\0';
	else
	{
		strcpy(buffer, " GRANTED BY ");
		strcat(buffer, grantor);
		fb_utils::exact_name(buffer);
	}

	return buffer;
}


static void set_grantee(int user_type, const char* SQL_identifier, char* user_string)
{
	switch (user_type)
	{
	case obj_view:
		sprintf(user_string, "VIEW %s", SQL_identifier);
		break;
	case obj_trigger:
		sprintf(user_string, "TRIGGER %s", SQL_identifier);
		break;
	case obj_procedure:
		sprintf(user_string, "PROCEDURE %s", SQL_identifier);
		break;
	case obj_udf:
		sprintf(user_string, "FUNCTION %s", SQL_identifier);
		break;
	case obj_user:
		if (strcmp(SQL_identifier, "PUBLIC"))
			sprintf(user_string, "USER %s", SQL_identifier);
		else
			strcpy(user_string, SQL_identifier);
		break;
	case obj_user_group:
		sprintf(user_string, "GROUP %s", SQL_identifier);
		break;
	case obj_sql_role:
		sprintf(user_string, "ROLE %s", SQL_identifier);
		break;
	case obj_package_header:
		sprintf(user_string, "PACKAGE %s", SQL_identifier);
		break;
	case obj_privilege:
		FOR T IN RDB$TYPES
			WITH T.RDB$FIELD_NAME EQ 'RDB$SYSTEM_PRIVILEGES' AND
				 T.RDB$TYPE EQ atoi(SQL_identifier)
		{
			sprintf(user_string, "SYSTEM PRIVILEGE %s", fb_utils::exact_name(T.RDB$TYPE_NAME));
		}
		END_FOR
		break;
	default:
		strcpy(user_string, SQL_identifier);
		break;
	}
}


static USHORT convert_privilege_to_code(char privilege)
{
	switch (privilege)
	{
	case 'S':
		return priv_SELECT;
	case 'I':
		return priv_INSERT;
	case 'U':
		return priv_UPDATE;
	case 'D':
		return priv_DELETE;
	case 'R':
		return priv_REFERENCES;
	case 'X':
	case 'G':
		// Execute should not be here
		return 0;
	}

	return priv_UNKNOWN;
}


static void make_privilege_string_with_fields(USHORT priv_flags,
											  const PrivilegeFields* priv_fields,
											  int priv_fields_count,
											  char* priv_string,
											  string& out_result)
{
	out_result = "";

	if (priv_flags)
	{
		make_priv_string(priv_flags, priv_string, false);
		out_result.assign(priv_string);
	}

	for (int i = 0; i < priv_fields_count; i++)
	{
		if (priv_fields[i].fields.isEmpty())
			continue;

		if (!out_result.isEmpty())
			out_result += ", ";
		out_result += priv_fields[i].privilege + (" (" + priv_fields[i].fields + ")");
	}
}


processing_state SHOW_grants2 (const SCHAR* object,
				  const SCHAR* terminator,
				  ObjectType obj_type,
				  const TEXT* optional_msg,
				  bool mangle)
{
/**************************************
 *
 *	S H O W _ g r a n t s 2
 *
 **************************************
 *
 * Functional description
 *	Show grants for given object name
 *	This function is also called by extract for privileges.
 *  	It must extract granted privileges on tables/views to users,
 *		- these may be compound, so put them on the same line.
 *	Grant execute privilege on procedures to users
 *	Grant various privilegs to procedures.
 *	All privileges may have the with_grant option set.
 *	The optional msg is to display a customized message. When the
 *	new feature of all grants is used, there's no way to print the
 *	header message after this routine, so it should be printed here.
 *
 **************************************/
	BASED_ON RDB$USER_PRIVILEGES.RDB$USER prev_user;
	BASED_ON RDB$USER_PRIVILEGES.RDB$GRANT_OPTION prev_grant_option;
	BASED_ON RDB$USER_PRIVILEGES.RDB$GRANTOR prev_grantor;
	SCHAR buf_grantor[sizeof(prev_grantor) + 20];
	SCHAR user_string[QUOTED_NAME_SIZE + 20];
	SCHAR obj_string[QUOTED_NAME_SIZE + 20];

	PrivilegeFields priv_fields[] =
	{
		{privs[PRIV_UPDATE_POS].priv_string, ""},
		{privs[PRIV_REFERENCES_POS].priv_string, ""}
	};
	const int priv_fields_count = FB_NELEM(priv_fields);

	bool first = true;

	if (!*object)
		return ps_ERR;

	// Query against user_privileges instead of looking at rdb$security_classes

	prev_grant_option = -1;
	prev_user[0] = '\0';
	prev_grantor[0] = '\0';
	char priv_string[MAX_PRIV_LIST] = "";
	string col_string;
	char with_option[19] = "";
	USHORT priv_flags = 0;

	if (obj_type == obj_relation || obj_type == obj_any)
	{
		// Find the user specified relation and show its privileges

		FOR FIRST 1 R IN RDB$RELATIONS WITH R.RDB$RELATION_NAME EQ object

			// This query only finds tables, eliminating owner privileges

			FOR PRV IN RDB$USER_PRIVILEGES CROSS
				REL IN RDB$RELATIONS WITH
				PRV.RDB$GRANTOR NOT MISSING		AND
				PRV.RDB$RELATION_NAME EQ object AND
				REL.RDB$RELATION_NAME EQ object AND
				PRV.RDB$PRIVILEGE     NE 'M'    AND
				REL.RDB$OWNER_NAME    NE PRV.RDB$USER
				SORTED BY PRV.RDB$USER, PRV.RDB$GRANT_OPTION, PRV.RDB$FIELD_NAME;

				fb_utils::exact_name(PRV.RDB$USER);

				// Sometimes grant options are null, sometimes 0.  Both same

				if (PRV.RDB$GRANT_OPTION.NULL)
					PRV.RDB$GRANT_OPTION = 0;

				if (PRV.RDB$FIELD_NAME.NULL)
					PRV.RDB$FIELD_NAME[0] = '\0';

				// Print a new grant statement for each new user or change of option

				if (prev_grant_option != -1 &&
					(strcmp(prev_user, PRV.RDB$USER) ||
					prev_grant_option != PRV.RDB$GRANT_OPTION ||
					strcmp(prev_grantor, PRV.RDB$GRANTOR)))
				{
					if (first && optional_msg)
						isqlGlob.prints(optional_msg);
					first = false;

					if (mangle && isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
						IUTILS_copy_SQL_id(object, SQL_identifier, DBL_QUOTE);
					else
						strcpy(SQL_identifier, object);

					if (prev_grant_option)
						strcpy(with_option, " WITH GRANT OPTION");

					string combine_privileges = "";
					make_privilege_string_with_fields(priv_flags, priv_fields, priv_fields_count,
						priv_string, combine_privileges);

					isqlGlob.printf("GRANT %s ON %s TO %s%s%s%s%s",
						combine_privileges.c_str(),
						SQL_identifier,
						user_string, with_option, granted_by(buf_grantor, prev_grantor, false),
						terminator, NEWLINE);

					// re-initialize
					priv_flags = 0;
					with_option[0] = '\0';
					priv_string[0] = '\0';
					col_string = "";
					for (int i = 0; i < priv_fields_count; i++)
						priv_fields[i].fields = "";
				}

				// At each row, store this value for the next compare of contol break

				strcpy (prev_user, PRV.RDB$USER);
				prev_grant_option = PRV.RDB$GRANT_OPTION;
				strcpy (prev_grantor, PRV.RDB$GRANTOR);

				switch (PRV.RDB$USER_TYPE)
				{
				case obj_relation:
				case obj_view:
				case obj_trigger:
				case obj_procedure:
				case obj_udf:
				case obj_sql_role:
				case obj_package_header:
				case obj_user: // Users can be machine\user and need quoting
					if (mangle && isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
						IUTILS_copy_SQL_id(PRV.RDB$USER, SQL_identifier, DBL_QUOTE);
					else
						strcpy(SQL_identifier, PRV.RDB$USER);
					break;
				default:
					strcpy(SQL_identifier, PRV.RDB$USER);
					break;
				}

				set_grantee(PRV.RDB$USER_TYPE, SQL_identifier, user_string);

				// Only the first character is used for permissions
				const char c = PRV.RDB$PRIVILEGE[0];

				// Column level privileges for update and references only
				if (PRV.RDB$FIELD_NAME.NULL)
				{
					col_string = "";
					priv_flags |= convert_privilege_to_code(c);
					continue;
				}
				else
				{
					fb_utils::exact_name(PRV.RDB$FIELD_NAME);
					if (mangle && isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
					{
						IUTILS_copy_SQL_id(PRV.RDB$FIELD_NAME, SQL_identifier, DBL_QUOTE);
						col_string = SQL_identifier;
					}
					else
					{
						col_string = PRV.RDB$FIELD_NAME;
					}
				}

				for (int i = 0; i < priv_fields_count; i++)
				{
					if (c == priv_fields[i].privilege[0])
					{
						priv_fields[i].fields += priv_fields[i].fields.isEmpty() ? col_string
							: ", " + col_string;
						break;
					}
				}

			END_FOR
			ON_ERROR
				ISQL_errmsg (fbStatus);
				return ps_ERR;
			END_ERROR;

			// Print last case if there was anything to print

			if (prev_grant_option != -1)
			{
				if (first && optional_msg)
					isqlGlob.prints(optional_msg);
				first = false;

				if (mangle && isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
					IUTILS_copy_SQL_id(object, SQL_identifier, DBL_QUOTE);
				else
					strcpy(SQL_identifier, object);

				if (prev_grant_option)
					strcpy(with_option, " WITH GRANT OPTION");

				string combine_privileges;
				make_privilege_string_with_fields(priv_flags, priv_fields, priv_fields_count,
					priv_string, combine_privileges);

				isqlGlob.printf("GRANT %s ON %s TO %s%s%s%s%s",
					combine_privileges.c_str(),
					SQL_identifier,
					user_string, with_option, granted_by(buf_grantor, prev_grantor, false),
					terminator, NEWLINE);
			}

		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR;

		if (!first)
			return (SKIP);
	}

	// No relation called "object" was found, try procedure "object"
	if (obj_type == obj_procedure || obj_type == obj_any)
	{
		FOR FIRST 1 P IN RDB$PROCEDURES WITH
			P.RDB$PROCEDURE_NAME EQ object AND
			P.RDB$PACKAGE_NAME MISSING

			// Part two is for stored procedures only

			FOR PRV IN RDB$USER_PRIVILEGES CROSS
				PRC IN RDB$PROCEDURES WITH
				PRV.RDB$GRANTOR NOT MISSING AND
				PRV.RDB$OBJECT_TYPE = obj_procedure AND
				PRV.RDB$RELATION_NAME EQ object AND
				PRC.RDB$PROCEDURE_NAME EQ object AND
				PRV.RDB$PRIVILEGE EQ 'X' AND
				PRC.RDB$OWNER_NAME NE PRV.RDB$USER AND
				PRC.RDB$PACKAGE_NAME MISSING
				SORTED BY PRV.RDB$USER, PRV.RDB$FIELD_NAME, PRV.RDB$GRANT_OPTION

				if (first && optional_msg)
					isqlGlob.prints(optional_msg);

				first = false;
				fb_utils::exact_name(PRV.RDB$USER);

				switch (PRV.RDB$USER_TYPE)
				{
				case obj_relation:
				case obj_view:
				case obj_trigger:
				case obj_procedure:
				case obj_udf:
				case obj_sql_role:
				case obj_package_header:
				case obj_user:
					if (mangle && isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
						IUTILS_copy_SQL_id(PRV.RDB$USER, SQL_identifier, DBL_QUOTE);
					else
						strcpy(SQL_identifier, PRV.RDB$USER);
					break;
				default:
					strcpy(SQL_identifier, PRV.RDB$USER);
					break;
				}

				set_grantee(PRV.RDB$USER_TYPE, SQL_identifier, user_string);

				if (PRV.RDB$GRANT_OPTION)
					strcpy(with_option, " WITH GRANT OPTION");
				else
					with_option[0] = '\0';

				if (mangle && isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
					IUTILS_copy_SQL_id(object, SQL_identifier, DBL_QUOTE);
				else
					strcpy(SQL_identifier, object);

				isqlGlob.printf("GRANT EXECUTE ON PROCEDURE %s TO %s%s%s%s%s",
						 SQL_identifier, user_string, with_option,
						 granted_by(buf_grantor, PRV.RDB$GRANTOR, PRV.RDB$GRANTOR.NULL), terminator, NEWLINE);

			END_FOR
			ON_ERROR
				ISQL_errmsg(fbStatus);
				return ps_ERR;
			END_ERROR
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR;

		if (!first)
			return (SKIP);
	}

	// No procedure called "object" was found, try role "object"
	SCHAR role_name[BUFFER_LENGTH256];

	if (obj_type == obj_sql_role || obj_type == obj_any)
	{
		// No procedure called "object" was found, try role "object"
		// CVC: This code could be superseded by SHOW_grant_roles() below
		// with the sole difference of the sort fields.
		// This part is only used by SHOW GRANT <object> command
		// Metadata extraction and SHOW GRANT with no param uses SHOW_grant_roles.

		FOR FIRST 1 R IN RDB$ROLES WITH R.RDB$ROLE_NAME EQ object

			FOR PRV IN RDB$USER_PRIVILEGES WITH
				PRV.RDB$GRANTOR NOT MISSING           AND
				PRV.RDB$OBJECT_TYPE   EQ obj_sql_role AND
				(PRV.RDB$USER_TYPE    EQ obj_user      OR
				 PRV.RDB$USER_TYPE    EQ obj_sql_role) AND
				PRV.RDB$RELATION_NAME EQ object       AND
				PRV.RDB$PRIVILEGE     EQ 'M'
				SORTED BY PRV.RDB$USER

				fb_utils::exact_name(PRV.RDB$RELATION_NAME);
				strcpy (role_name, PRV.RDB$RELATION_NAME);
				if (mangle && isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
					IUTILS_copy_SQL_id(role_name, SQL_identifier, DBL_QUOTE);
				else
					strcpy(SQL_identifier, role_name);

				fb_utils::exact_name(PRV.RDB$USER);
				strcpy(user_string, PRV.RDB$USER);

				if (PRV.RDB$GRANT_OPTION)
					strcpy(with_option, " WITH ADMIN OPTION");
				else
					with_option[0] = '\0';

				const char* default_option = "";
				if (!PRV.RDB$FIELD_NAME.NULL && PRV.RDB$FIELD_NAME[0] == 'D')
					default_option = " DEFAULT";

				fb_utils::snprintf(Print_buffer, sizeof(Print_buffer), "GRANT%s %s TO %s%s%s%s%s",
						default_option, SQL_identifier,
						user_string, with_option, granted_by(buf_grantor, PRV.RDB$GRANTOR, PRV.RDB$GRANTOR.NULL),
						terminator, NEWLINE);

				if (first && optional_msg)
					isqlGlob.prints(optional_msg);

				first = false;
				isqlGlob.prints(Print_buffer);

			END_FOR
			ON_ERROR
				ISQL_errmsg(fbStatus);
				return ps_ERR;
			END_ERROR;

		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR;

		if (!first)
			return (SKIP);
	}

	if (obj_type == obj_package_header || obj_type == obj_any)
	{
		if (isqlGlob.major_ods >= ODS_VERSION12)
		{
			FOR FIRST 1 P IN RDB$PACKAGES WITH P.RDB$PACKAGE_NAME EQ object
				FOR PRV IN RDB$USER_PRIVILEGES CROSS
					PACK IN RDB$PACKAGES WITH
					PRV.RDB$GRANTOR NOT MISSING AND
					PRV.RDB$OBJECT_TYPE = obj_package_header AND
					PRV.RDB$RELATION_NAME EQ object AND
					PACK.RDB$PACKAGE_NAME EQ object AND
					PRV.RDB$PRIVILEGE EQ 'X' AND
					PACK.RDB$OWNER_NAME NE PRV.RDB$USER
					SORTED BY PRV.RDB$USER, PRV.RDB$FIELD_NAME, PRV.RDB$GRANT_OPTION

					if (first && optional_msg)
						isqlGlob.prints(optional_msg);

					first = false;
					fb_utils::exact_name(PRV.RDB$USER);

					switch (PRV.RDB$USER_TYPE)
					{
					case obj_relation:
					case obj_view:
					case obj_trigger:
					case obj_procedure:
					case obj_udf:
					case obj_sql_role:
					case obj_package_header:
					case obj_user:
						if (mangle && isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
							IUTILS_copy_SQL_id(PRV.RDB$USER, SQL_identifier, DBL_QUOTE);
						else
							strcpy(SQL_identifier, PRV.RDB$USER);
						break;
					default:
						strcpy(SQL_identifier, PRV.RDB$USER);
						break;
					}

					set_grantee(PRV.RDB$USER_TYPE, SQL_identifier, user_string);

					if (PRV.RDB$GRANT_OPTION)
						strcpy(with_option, " WITH GRANT OPTION");
					else
						with_option[0] = '\0';

					if (mangle && isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
						IUTILS_copy_SQL_id(object, SQL_identifier, DBL_QUOTE);
					else
						strcpy(SQL_identifier, object);

					isqlGlob.printf("GRANT EXECUTE ON PACKAGE %s TO %s%s%s%s%s",
							 SQL_identifier, user_string, with_option,
							 granted_by(buf_grantor, PRV.RDB$GRANTOR, PRV.RDB$GRANTOR.NULL),
							 terminator, NEWLINE);

				END_FOR
				ON_ERROR
					ISQL_errmsg(fbStatus);
					return ps_ERR;
				END_ERROR
			END_FOR
			ON_ERROR
				ISQL_errmsg(fbStatus);
				return ps_ERR;
			END_ERROR;

			if (!first)
				return (SKIP);
		}
	}

	if (obj_type == obj_udf || obj_type == obj_any)
	{
		if (isqlGlob.major_ods >= ODS_VERSION12)
		{
			FOR FIRST 1 F IN RDB$FUNCTIONS
			WITH F.RDB$FUNCTION_NAME EQ object AND
				 F.RDB$PACKAGE_NAME MISSING

				FOR PRV IN RDB$USER_PRIVILEGES CROSS
					FUN IN RDB$FUNCTIONS WITH
					PRV.RDB$GRANTOR NOT MISSING AND
					PRV.RDB$OBJECT_TYPE = obj_udf AND
					PRV.RDB$RELATION_NAME EQ object AND
					FUN.RDB$FUNCTION_NAME EQ object AND
					FUN.RDB$PACKAGE_NAME MISSING AND
					PRV.RDB$PRIVILEGE EQ 'X' AND
					FUN.RDB$OWNER_NAME NE PRV.RDB$USER
					SORTED BY PRV.RDB$USER, PRV.RDB$FIELD_NAME, PRV.RDB$GRANT_OPTION

					if (first && optional_msg)
						isqlGlob.prints(optional_msg);

					first = false;
					fb_utils::exact_name(PRV.RDB$USER);

					switch (PRV.RDB$USER_TYPE)
					{
					case obj_relation:
					case obj_view:
					case obj_trigger:
					case obj_procedure:
					case obj_udf:
					case obj_sql_role:
					case obj_package_header:
					case obj_user:
						if (mangle && isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
							IUTILS_copy_SQL_id(PRV.RDB$USER, SQL_identifier, DBL_QUOTE);
						else
							strcpy(SQL_identifier, PRV.RDB$USER);
						break;
					default:
						strcpy(SQL_identifier, PRV.RDB$USER);
						break;
					}

					set_grantee(PRV.RDB$USER_TYPE, SQL_identifier, user_string);

					if (PRV.RDB$GRANT_OPTION)
						strcpy(with_option, " WITH GRANT OPTION");
					else
						with_option[0] = '\0';

					if (mangle && isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
						IUTILS_copy_SQL_id(object, SQL_identifier, DBL_QUOTE);
					else
						strcpy(SQL_identifier, object);

					isqlGlob.printf("GRANT EXECUTE ON FUNCTION %s TO %s%s%s%s%s",
							 SQL_identifier, user_string, with_option,
							 granted_by(buf_grantor, PRV.RDB$GRANTOR, PRV.RDB$GRANTOR.NULL),
							 terminator, NEWLINE);

				END_FOR
				ON_ERROR
					ISQL_errmsg(fbStatus);
					return ps_ERR;
				END_ERROR
			END_FOR
			ON_ERROR
				ISQL_errmsg(fbStatus);
				return ps_ERR;
			END_ERROR;

			if (!first)
				return (SKIP);
		}
	}

	if (obj_type == obj_generator || obj_type == obj_any)
	{
		if (isqlGlob.major_ods >= ODS_VERSION12)
		{
			FOR FIRST 1 G IN RDB$GENERATORS WITH G.RDB$GENERATOR_NAME EQ object
				FOR PRV IN RDB$USER_PRIVILEGES CROSS
					GEN IN RDB$GENERATORS WITH
					PRV.RDB$GRANTOR NOT MISSING AND
					PRV.RDB$OBJECT_TYPE = obj_generator AND
					PRV.RDB$RELATION_NAME EQ object AND
					GEN.RDB$GENERATOR_NAME EQ object AND
					PRV.RDB$PRIVILEGE EQ 'G' AND
					GEN.RDB$OWNER_NAME NE PRV.RDB$USER
					SORTED BY PRV.RDB$USER, PRV.RDB$FIELD_NAME, PRV.RDB$GRANT_OPTION

					if (first && optional_msg)
						isqlGlob.prints(optional_msg);

					first = false;
					fb_utils::exact_name(PRV.RDB$USER);

					switch (PRV.RDB$USER_TYPE)
					{
					case obj_relation:
					case obj_view:
					case obj_trigger:
					case obj_procedure:
					case obj_udf:
					case obj_sql_role:
					case obj_package_header:
					case obj_user:
						if (mangle && isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
							IUTILS_copy_SQL_id(PRV.RDB$USER, SQL_identifier, DBL_QUOTE);
						else
							strcpy(SQL_identifier, PRV.RDB$USER);
						break;
					default:
						strcpy(SQL_identifier, PRV.RDB$USER);
						break;
					}

					set_grantee(PRV.RDB$USER_TYPE, SQL_identifier, user_string);

					if (PRV.RDB$GRANT_OPTION)
						strcpy(with_option, " WITH GRANT OPTION");
					else
						with_option[0] = '\0';

					if (mangle && isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
						IUTILS_copy_SQL_id(object, SQL_identifier, DBL_QUOTE);
					else
						strcpy(SQL_identifier, object);

					isqlGlob.printf("GRANT USAGE ON SEQUENCE %s TO %s%s%s%s%s",
							 SQL_identifier, user_string, with_option,
							 granted_by(buf_grantor, PRV.RDB$GRANTOR, PRV.RDB$GRANTOR.NULL),
							 terminator, NEWLINE);

				END_FOR
				ON_ERROR
					ISQL_errmsg(fbStatus);
					return ps_ERR;
				END_ERROR
			END_FOR
			ON_ERROR
				ISQL_errmsg(fbStatus);
				return ps_ERR;
			END_ERROR;

			if (!first)
				return (SKIP);
		}
	}

	if (obj_type == obj_exception || obj_type == obj_any)
	{
		if (isqlGlob.major_ods >= ODS_VERSION12)
		{
			FOR FIRST 1 E IN RDB$EXCEPTIONS WITH E.RDB$EXCEPTION_NAME EQ object
				FOR PRV IN RDB$USER_PRIVILEGES CROSS
					XCP IN RDB$EXCEPTIONS WITH
					PRV.RDB$GRANTOR NOT MISSING AND
					PRV.RDB$OBJECT_TYPE = obj_exception AND
					PRV.RDB$RELATION_NAME EQ object AND
					XCP.RDB$EXCEPTION_NAME EQ object AND
					PRV.RDB$PRIVILEGE EQ 'G' AND
					XCP.RDB$OWNER_NAME NE PRV.RDB$USER
					SORTED BY PRV.RDB$USER, PRV.RDB$FIELD_NAME, PRV.RDB$GRANT_OPTION

					if (first && optional_msg)
						isqlGlob.prints(optional_msg);

					first = false;
					fb_utils::exact_name(PRV.RDB$USER);

					switch (PRV.RDB$USER_TYPE)
					{
					case obj_relation:
					case obj_view:
					case obj_trigger:
					case obj_procedure:
					case obj_udf:
					case obj_sql_role:
					case obj_package_header:
					case obj_user:
						if (mangle && isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
							IUTILS_copy_SQL_id(PRV.RDB$USER, SQL_identifier, DBL_QUOTE);
						else
							strcpy(SQL_identifier, PRV.RDB$USER);
						break;
					default:
						strcpy(SQL_identifier, PRV.RDB$USER);
						break;
					}

					set_grantee(PRV.RDB$USER_TYPE, SQL_identifier, user_string);

					if (PRV.RDB$GRANT_OPTION)
						strcpy(with_option, " WITH GRANT OPTION");
					else
						with_option[0] = '\0';

					if (mangle && isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
						IUTILS_copy_SQL_id(object, SQL_identifier, DBL_QUOTE);
					else
						strcpy(SQL_identifier, object);

					isqlGlob.printf("GRANT USAGE ON EXCEPTION %s TO %s%s%s%s%s",
							 SQL_identifier, user_string, with_option,
							 granted_by(buf_grantor, PRV.RDB$GRANTOR, PRV.RDB$GRANTOR.NULL),
							 terminator, NEWLINE);

				END_FOR
				ON_ERROR
					ISQL_errmsg(fbStatus);
					return ps_ERR;
				END_ERROR
			END_FOR
			ON_ERROR
				ISQL_errmsg(fbStatus);
				return ps_ERR;
			END_ERROR;

			if (!first)
				return (SKIP);
		}
	}

	/***
	if (obj_type == obj_field || obj_type == 255)
	{
		if (isqlGlob.major_ods >= ODS_VERSION12)
		{
			FOR FIRST 1 F IN RDB$FIELDS WITH F.RDB$FIELD_NAME EQ object
				FOR PRV IN RDB$USER_PRIVILEGES CROSS
					FLD IN RDB$FIELDS WITH
					PRV.RDB$GRANTOR NOT MISSING AND
					PRV.RDB$OBJECT_TYPE = obj_field AND
					PRV.RDB$RELATION_NAME EQ object AND
					FLD.RDB$FIELD_NAME EQ object AND
					PRV.RDB$PRIVILEGE EQ 'G' AND
					FLD.RDB$OWNER_NAME NE PRV.RDB$USER
					SORTED BY PRV.RDB$USER, PRV.RDB$FIELD_NAME, PRV.RDB$GRANT_OPTION

					if (first && optional_msg)
						isqlGlob.prints(optional_msg);

					first = false;
					fb_utils::exact_name(PRV.RDB$USER);

					switch (PRV.RDB$USER_TYPE)
					{
					case obj_relation:
					case obj_view:
					case obj_trigger:
					case obj_procedure:
					case obj_udf:
					case obj_sql_role:
					case obj_package_header:
					case obj_user:
						if (mangle && isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
							IUTILS_copy_SQL_id(PRV.RDB$USER, SQL_identifier, DBL_QUOTE);
						else
							strcpy(SQL_identifier, PRV.RDB$USER);
						break;
					default:
						strcpy(SQL_identifier, PRV.RDB$USER);
						break;
					}

					set_grantee(PRV.RDB$USER_TYPE, SQL_identifier, user_string);

					if (PRV.RDB$GRANT_OPTION)
						strcpy(with_option, " WITH GRANT OPTION");
					else
						with_option[0] = '\0';

					if (mangle && isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
						IUTILS_copy_SQL_id(object, SQL_identifier, DBL_QUOTE);
					else
						strcpy(SQL_identifier, object);

					isqlGlob.printf("GRANT USAGE ON DOMAIN %s TO %s%s%s%s%s",
							 SQL_identifier, user_string, with_option,
							 granted_by(buf_grantor, PRV.RDB$GRANTOR, PRV.RDB$GRANTOR.NULL),
							 terminator, NEWLINE);

				END_FOR
				ON_ERROR
					ISQL_errmsg(fbStatus);
					return ps_ERR;
				END_ERROR
			END_FOR
			ON_ERROR
				ISQL_errmsg(fbStatus);
				return ps_ERR;
			END_ERROR;

			if (!first)
				return (SKIP);
		}
	}

	if (obj_type == obj_charset || obj_type == 255)
	{
		if (isqlGlob.major_ods >= ODS_VERSION12)
		{
			FOR FIRST 1 C IN RDB$CHARACTER_SETS WITH C.RDB$CHARACTER_SET_NAME EQ object
				FOR PRV IN RDB$USER_PRIVILEGES CROSS
					CS IN RDB$CHARACTER_SETS WITH
					PRV.RDB$GRANTOR NOT MISSING AND
					PRV.RDB$OBJECT_TYPE = obj_charset AND
					PRV.RDB$RELATION_NAME EQ object AND
					CS.RDB$CHARACTER_SET_NAME EQ object AND
					PRV.RDB$PRIVILEGE EQ 'G' AND
					CS.RDB$OWNER_NAME NE PRV.RDB$USER
					SORTED BY PRV.RDB$USER, PRV.RDB$FIELD_NAME, PRV.RDB$GRANT_OPTION

					if (first && optional_msg)
						isqlGlob.prints(optional_msg);

					first = false;
					fb_utils::exact_name(PRV.RDB$USER);

					switch (PRV.RDB$USER_TYPE)
					{
					case obj_relation:
					case obj_view:
					case obj_trigger:
					case obj_procedure:
					case obj_udf:
					case obj_sql_role:
					case obj_package_header:
					case obj_user:
						if (mangle && isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
							IUTILS_copy_SQL_id(PRV.RDB$USER, SQL_identifier, DBL_QUOTE);
						else
							strcpy(SQL_identifier, PRV.RDB$USER);
						break;
					default:
						strcpy(SQL_identifier, PRV.RDB$USER);
						break;
					}

					set_grantee(PRV.RDB$USER_TYPE, SQL_identifier, user_string);

					if (PRV.RDB$GRANT_OPTION)
						strcpy(with_option, " WITH GRANT OPTION");
					else
						with_option[0] = '\0';

					if (mangle && isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
						IUTILS_copy_SQL_id(object, SQL_identifier, DBL_QUOTE);
					else
						strcpy(SQL_identifier, object);

					isqlGlob.printf("GRANT USAGE ON CHARACTER SET %s TO %s%s%s%s%s",
							 SQL_identifier, user_string, with_option,
							 granted_by(buf_grantor, PRV.RDB$GRANTOR, PRV.RDB$GRANTOR.NULL),
							 terminator, NEWLINE);

				END_FOR
				ON_ERROR
					ISQL_errmsg(fbStatus);
					return ps_ERR;
				END_ERROR
			END_FOR
			ON_ERROR
				ISQL_errmsg(fbStatus);
				return ps_ERR;
			END_ERROR;

			if (!first)
				return (SKIP);
		}
	}

	if (obj_type == obj_collation || obj_type == 255)
	{
		if (isqlGlob.major_ods >= ODS_VERSION12)
		{
			FOR FIRST 1 C IN RDB$COLLATIONS WITH C.RDB$COLLATION_NAME EQ object
				FOR PRV IN RDB$USER_PRIVILEGES CROSS
					COL IN RDB$COLLATIONS WITH
					PRV.RDB$GRANTOR NOT MISSING AND
					PRV.RDB$OBJECT_TYPE = obj_collation AND
					PRV.RDB$RELATION_NAME EQ object AND
					COL.RDB$COLLATION_NAME EQ object AND
					PRV.RDB$PRIVILEGE EQ 'G' AND
					COL.RDB$OWNER_NAME NE PRV.RDB$USER
					SORTED BY PRV.RDB$USER, PRV.RDB$FIELD_NAME, PRV.RDB$GRANT_OPTION

					if (first && optional_msg)
						isqlGlob.prints(optional_msg);

					first = false;
					fb_utils::exact_name(PRV.RDB$USER);

					switch (PRV.RDB$USER_TYPE)
					{
					case obj_relation:
					case obj_view:
					case obj_trigger:
					case obj_procedure:
					case obj_udf:
					case obj_sql_role:
					case obj_package_header:
					case obj_user:
						if (mangle && isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
							IUTILS_copy_SQL_id(PRV.RDB$USER, SQL_identifier, DBL_QUOTE);
						else
							strcpy(SQL_identifier, PRV.RDB$USER);
						break;
					default:
						strcpy(SQL_identifier, PRV.RDB$USER);
						break;
					}

					set_grantee(PRV.RDB$USER_TYPE, SQL_identifier, user_string);

					if (PRV.RDB$GRANT_OPTION)
						strcpy(with_option, " WITH GRANT OPTION");
					else
						with_option[0] = '\0';

					if (mangle && isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
						IUTILS_copy_SQL_id(object, SQL_identifier, DBL_QUOTE);
					else
						strcpy(SQL_identifier, object);

					isqlGlob.printf("GRANT USAGE ON COLLATION %s TO %s%s%s%s%s",
							 SQL_identifier, user_string, with_option,
							 granted_by(buf_grantor, PRV.RDB$GRANTOR, PRV.RDB$GRANTOR.NULL),
							 terminator, NEWLINE);

				END_FOR
				ON_ERROR
					ISQL_errmsg(fbStatus);
					return ps_ERR;
				END_ERROR
			END_FOR
			ON_ERROR
				ISQL_errmsg(fbStatus);
				return ps_ERR;
			END_ERROR;

			if (!first)
				return (SKIP);
		}
	}
	***/

	if (isDdlObject(obj_type) || obj_type == obj_any)
	{
		if (isqlGlob.major_ods >= ODS_VERSION12)
		{
			FOR PRV IN RDB$USER_PRIVILEGES WITH
				PRV.RDB$GRANTOR NOT MISSING AND
				PRV.RDB$OBJECT_TYPE >= obj_database AND
				PRV.RDB$RELATION_NAME EQ object
				SORTED BY PRV.RDB$USER, PRV.RDB$GRANT_OPTION

				// Double check if the object is DDL one.
				if (!isDdlObject(PRV.RDB$OBJECT_TYPE))
					continue;

				if (first && optional_msg)
					isqlGlob.prints(optional_msg);

				// re-initialize strings
				priv_string[0] = '\0';
				with_option[0] = '\0';
				priv_flags = 0;

				first = false;
				fb_utils::exact_name(PRV.RDB$USER);

				// Only the first character is used for permissions

				const char c = PRV.RDB$PRIVILEGE[0];

				switch (c)
				{
				case 'C':
					priv_flags |= priv_CREATE;
					break;
				case 'L':
					priv_flags |= priv_ALTER;
					break;
				case 'O':
					priv_flags |= priv_DROP;
					break;
				default:
					priv_flags |= priv_UNKNOWN;
					break;
				}

				make_priv_string(priv_flags, priv_string, (PRV.RDB$OBJECT_TYPE != obj_database));

				switch (PRV.RDB$USER_TYPE)
				{
				case obj_relation:
				case obj_view:
				case obj_trigger:
				case obj_procedure:
				case obj_udf:
				case obj_sql_role:
				case obj_package_header:
				case obj_user:
					if (mangle && isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
						IUTILS_copy_SQL_id(PRV.RDB$USER, SQL_identifier, DBL_QUOTE);
					else
						strcpy(SQL_identifier, PRV.RDB$USER);
					break;
				default:
					strcpy(SQL_identifier, PRV.RDB$USER);
					break;
				}

				set_grantee(PRV.RDB$USER_TYPE, SQL_identifier, user_string);

				strcpy(obj_string, getDdlObjectName(PRV.RDB$OBJECT_TYPE));

				if (PRV.RDB$GRANT_OPTION)
					strcpy(with_option, " WITH GRANT OPTION");
				else
					with_option[0] = '\0';

				isqlGlob.printf("GRANT %s %s TO %s%s%s%s%s",
						 priv_string, obj_string, user_string, with_option,
						 granted_by(buf_grantor, PRV.RDB$GRANTOR, PRV.RDB$GRANTOR.NULL),
						 terminator, NEWLINE);

			END_FOR
			ON_ERROR
				ISQL_errmsg(fbStatus);
				return ps_ERR;
			END_ERROR

			if (obj_type == obj_database || obj_type == obj_any)
			{
				FOR PRV IN SEC$DB_CREATORS
					SORTED BY PRV.SEC$USER_TYPE, PRV.SEC$USER

					if (first && optional_msg)
						isqlGlob.prints(optional_msg);

					first = false;
					fb_utils::exact_name(PRV.SEC$USER);

					switch (PRV.SEC$USER_TYPE)
					{
					case obj_sql_role:
					case obj_user:
						if (mangle && isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
							IUTILS_copy_SQL_id(PRV.SEC$USER, SQL_identifier, DBL_QUOTE);
						else
							strcpy(SQL_identifier, PRV.SEC$USER);
						break;
					default:
						fb_assert(false);
						strcpy(SQL_identifier, PRV.SEC$USER);
						break;
					}

					set_grantee(PRV.SEC$USER_TYPE, SQL_identifier, user_string);

					isqlGlob.printf("GRANT CREATE DATABASE TO %s%s%s",
						user_string, terminator, NEWLINE);

				END_FOR
				ON_ERROR
					ISQL_errmsg(fbStatus);
					return ps_ERR;
				END_ERROR
			}

			if (!first)
				return (SKIP);
		}
	}

	return OBJECT_NOT_FOUND;
}


void SHOW_grant_roles(const SCHAR* terminator, bool* first)
{
/**************************************
 *
 *	S H O W _ g r a n t _ r o l e s
 *
 **************************************
 *
 * Functional description
 *	Placeholder for SHOW_grant_roles2 without additional message.
 *
 **************************************/
	SHOW_grant_roles2 (terminator, first, 0, false);
}

void SHOW_grant_roles2 (const SCHAR* terminator,
						bool* first,
						const TEXT* optional_msg,
						bool mangle)
{
/**************************************
 *
 *	S H O W _ g r a n t _ r o l e s
 *
 **************************************
 *
 * Functional description
 *	Show grants for each role name
 *	This function is also called by extract for privileges.
 *	All membership privilege may have the with_admin or/and default options set.
 *
 **************************************/
	TEXT SQL_identifier2[BUFFER_LENGTH256];
	BASED_ON RDB$USER_PRIVILEGES.RDB$GRANTOR dummy;	// used to declare buf_grantor
	FB_UNUSED_VAR(dummy); // Silence compiler warning about unused variable
	SCHAR buf_grantor[sizeof(dummy) + 20];

	// process role "object"

	FOR PRV IN RDB$USER_PRIVILEGES WITH
		PRV.RDB$GRANTOR NOT MISSING           AND
		PRV.RDB$OBJECT_TYPE   EQ obj_sql_role AND
		(PRV.RDB$USER_TYPE    EQ obj_user      OR
		 PRV.RDB$USER_TYPE     EQ obj_sql_role) AND
		PRV.RDB$PRIVILEGE     EQ 'M'
		SORTED BY PRV.RDB$RELATION_NAME, PRV.RDB$USER

		if (first)
		{
			if (*first && optional_msg) {
				isqlGlob.prints(optional_msg);
			}
			*first = false;
		}

		const char* user_string = fb_utils::exact_name(PRV.RDB$USER);

		const char* with_option = "";
		if (PRV.RDB$GRANT_OPTION)
			with_option = " WITH ADMIN OPTION";
		const char* default_option = "";
		if (!PRV.RDB$FIELD_NAME.NULL && PRV.RDB$FIELD_NAME[0] == 'D')
			default_option = " DEFAULT";

		const char* role = fb_utils::exact_name(PRV.RDB$RELATION_NAME);
		const char* grantor = fb_utils::exact_name(PRV.RDB$GRANTOR);
		if (mangle && isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
		{
			IUTILS_copy_SQL_id (PRV.RDB$RELATION_NAME, SQL_identifier, DBL_QUOTE);
			role = SQL_identifier;
			IUTILS_copy_SQL_id(PRV.RDB$USER, SQL_identifier2, DBL_QUOTE);
			user_string = SQL_identifier2;
		}
		isqlGlob.printf("GRANT%s %s TO %s%s%s%s%s", default_option, role,
			user_string, with_option, granted_by(buf_grantor, grantor, false), terminator, NEWLINE);

	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
	END_ERROR;

}


void SHOW_print_metadata_text_blob(FILE* fp, ISC_QUAD* blobid, bool escape_squote, bool avoid_end_in_single_line_comment)
{
/**************************************
 *
 *	S H O W _ p r i n t _ m e t a d a t a _ t e x t _ b l o b
 *
 **************************************
 *
 * Functional description
 *	Print a Blob that is known to be metadata text.
 *	The last param says whether single quotes should be escaped (duplicating them).
 *
 **************************************/

	// Don't bother with null blobs
	if (UserBlob::blobIsNull(*blobid))
		return;

	Firebird::IBlob* blob = DB->openBlob(fbStatus, fbTrans, blobid,
		sizeof(metadata_text_bpb), metadata_text_bpb);
	if (ISQL_errmsg(fbStatus))
		return;

	string fullText;
	SCHAR buffer[BUFFER_LENGTH512];
	bool endedWithCr = false;

	while (true)
	{
		unsigned int length;
		int cc = blob->getSegment(fbStatus, sizeof(buffer) - 1, buffer, &length);
		if (cc == Firebird::IStatus::RESULT_NO_DATA || cc == Firebird::IStatus::RESULT_ERROR)
			break;

		// ASF: In Windows, \n characters are printed as \r\n in text mode.
		// If the original string has \r\n, they're printed as \r\r\n, resulting
		// in mixed/wrong line endings. So here, we filter any \r present just
		// before \n.
		bool prevEndedWithCr = endedWithCr;

		if ((endedWithCr = length != 0 && buffer[length - 1] == '\r'))
			--length;

		buffer[length] = 0;

		for (SCHAR* p = buffer; p < buffer + length - 1; ++p)
		{
			if (p[0] == '\r' && p[1] == '\n')
			{
				memmove(p, p + 1, length - (p - buffer));
				--length;
			}
		}

		if (prevEndedWithCr && buffer[0] != '\n')
		{
			fputc('\r', fp);
			if (avoid_end_in_single_line_comment)
				fullText += "\r";
		}

		if (escape_squote)
		{
			for (const UCHAR* p = (UCHAR*) buffer; *p; ++p)
			{
				if (*p == SINGLE_QUOTE)
				{
					fputc(*p, fp);
					if (avoid_end_in_single_line_comment)
						fullText += *p;
				}

				fputc(*p, fp);
				if (avoid_end_in_single_line_comment)
					fullText += *p;
			}
			fflush(fp);
		}
		else
		{
			IUTILS_printf(fp, buffer);
			if (avoid_end_in_single_line_comment)
				fullText += buffer;
		}
	}

	if (endedWithCr)
	{
		fputc('\r', fp);
		if (avoid_end_in_single_line_comment)
			fullText += "\r";
	}

	if (fbStatus->getState() & Firebird::IStatus::STATE_ERRORS)
		ISQL_errmsg(fbStatus);

	blob->close(fbStatus);

	if (avoid_end_in_single_line_comment && ISQL_statement_ends_in_comment(fullText.c_str()))
		fputc('\n', fp);
}


processing_state SHOW_metadata(const FrontendParser::AnyShowNode& node)
{
/**************************************
 *
 *	S H O W _ m e t a d a t a
 *
 **************************************
 *
 * Functional description
 *	If somebody presses the show ..., come here to
 *	interpret the desired command.
 *
 **************************************/

	static const OptionsBase::optionsMap options[] =
	{
		{0, "ROLES", 4},				// ROLE
		{0, "TABLES", 5},				// TABLE
		{0, "VIEWS", 4},				// VIEW
		{0, "SYSTEM", 3},				// SYS
		{0, "INDEXES", 3},				// IND
		{0, "INDICES", 0},
		{0, "DOMAINS", 6},				// DOMAIN
		{0, "EXCEPTIONS", 5},			// EXCEPTION
		{0, "FILTERS", 6},				// FILTER
		{0, "FUNCTIONS", 4},			// FUNCTION
		{0, "GENERATORS", 3},			// GEN
		{0, "SEQUENCES", 3},			// SEQ
		{0, "GRANTS", 5},				// GRANT
		{0, "PROCEDURES", 4},			// PROC
		{0, "TRIGGERS", 4},				// TRIG
		{0, "CHECKS", 5},				// CHECK
		{0, "DB", 0},
		{0, "DATABASE", 0},
		{0, "COMMENTS", 7},				// COMMENT
		{0, "DEPENDENCY", 5},			// DEPEN
		{0, "DEPENDENCIES", 5},			// DEPEN
		{0, "COLLATES", 7},				// COLLATE
		{0, "COLLATIONS", 9},			// COLLATION
		{0, "SECCLASSES", 6},			// SECCLA
		{0, "USERS", 0},
		{0, "PACKAGES", 4},				// PACK
		///{0, "SCHEMAS", 4},				// SCHE
		{0, "MAPPINGS", 3},				// MAP
		{0, "PUBLICATIONS", 3},			// PUB
		{0, "WIRE_STATISTICS", 9},		// WIRE_STAT
		{0, "WIRE_STATS", 10}
	};

	const OptionsBase showoptions(options, FB_NELEM(options), 0);

	if (!std::holds_alternative<FrontendParser::ShowSqlDialectNode>(node) &&
		!std::holds_alternative<FrontendParser::ShowVersionNode>(node))
	{
		if (!ISQL_dbcheck())
			return ps_ERR;
	}

	int key = 0;
	MetaString notFoundName;

	const auto ret = std::visit(StdVisitOverloads{
		[](const FrontendParser::InvalidNode&)
		{
			return CONT;
		},

		[&](const FrontendParser::ShowNode& node)
		{
			TEXT msg_string[MSG_LENGTH];
			IUTILS_msg_get(VALID_OPTIONS, msg_string);
			isqlGlob.printf("%s\n", msg_string);
			showoptions.showCommands(isqlGlob.Out);
			return ps_ERR;
		},

		[&](const FrontendParser::ShowChecksNode& node)
		{
			const auto ret = show_check((node.name ? node.name->c_str() : ""));

			if (ret == OBJECT_NOT_FOUND)
			{
				if (node.name)
				{
					FOR FIRST 1 R IN RDB$RELATIONS
						WITH R.RDB$RELATION_NAME EQ node.name->c_str()
					{
						key = NO_CHECKS_ON_REL;
					}
					END_FOR
					ON_ERROR
						// Ignore any error
					END_ERROR

					notFoundName = node.name.value();
				}

				if (!key)
					key = NO_TABLE;
			}

			return ret;
		},

		[&](const FrontendParser::ShowCollationsNode& node)
		{
			const auto ret = show_collations((node.name ? node.name->c_str() : ""), 0);

			if (ret == OBJECT_NOT_FOUND)
			{
				if (node.name)
				{
					key = NO_COLLATION;
					notFoundName = node.name.value();
				}
				else
					key = NO_COLLATIONS;
			}

			return ret;
		},

		[&](const FrontendParser::ShowCommentsNode&)
		{
			const auto ret = show_comments(cmmShow, 0);

			if (ret == OBJECT_NOT_FOUND)
				key = NO_COMMENTS;

			return ret;
		},

		[](const FrontendParser::ShowDatabaseNode&)
		{
			show_db();
			return SKIP;
		},

		[&](const FrontendParser::ShowDependenciesNode& node)
		{
			const auto ret = show_dependencies((node.name ? node.name->c_str() : ""));

			if (ret == OBJECT_NOT_FOUND)
				key = NO_DEPENDENCIES;

			return ret;
		},

		[&](const FrontendParser::ShowDomainsNode& node)
		{
			const auto ret = show_domains((node.name ? node.name->c_str() : ""));

			if (ret == OBJECT_NOT_FOUND)
			{
				if (node.name)
				{
					key = NO_DOMAIN;
					notFoundName = node.name.value();
				}
				else
					key = NO_DOMAINS;
			}

			return ret;
		},

		[&](const FrontendParser::ShowExceptionsNode& node)
		{
			const auto ret = show_exceptions((node.name ? node.name->c_str() : ""));

			if (ret == OBJECT_NOT_FOUND)
			{
				if (node.name)
				{
					key = NO_EXCEPTION;
					notFoundName = node.name.value();
				}
				else
					key = NO_EXCEPTIONS;
			}

			return ret;
		},

		[&](const FrontendParser::ShowFiltersNode& node)
		{
			const auto ret = show_filters((node.name ? node.name->c_str() : ""));

			if (ret == OBJECT_NOT_FOUND)
			{
				if (node.name)
				{
					key = NO_FILTER;
					notFoundName = node.name.value();
				}
				else
					key = NO_FILTERS;
			}

			return ret;
		},

		[&](const FrontendParser::ShowFunctionsNode& node)
		{
			const auto ret = show_functions(
				(node.name ? node.name->c_str() : ""),
				(node.package ? node.package->c_str() : ""),
				false, false);

			if (ret == OBJECT_NOT_FOUND)
			{
				if (node.name)
				{
					key = NO_FUNCTION;
					notFoundName = node.name.value();
				}
				else
					key = NO_FUNCTIONS;
			}

			return ret;
		},

		[&](const FrontendParser::ShowGeneratorsNode& node)
		{
			const auto ret = show_generators((node.name ? node.name->c_str() : ""));

			if (ret == OBJECT_NOT_FOUND)
			{
				if (node.name)
				{
					key = NO_GEN;
					notFoundName = node.name.value();
				}
				else
					key = NO_GENS;
			}

			return ret;
		},

		[&](const FrontendParser::ShowGrantsNode& node)
		{
			processing_state ret;

			if (node.name)
				ret = SHOW_grants(node.name->c_str(), "", obj_any);
			else
				ret = EXTRACT_list_grants("");

			if (ret == OBJECT_NOT_FOUND)
			{
				if (node.name)
				{
					FOR FIRST 1 R IN RDB$RELATIONS
						WITH R.RDB$RELATION_NAME EQ node.name->c_str()
					{
						key = NO_GRANT_ON_REL;
					}
					END_FOR
					ON_ERROR
						// Ignore any error
					END_ERROR

					if (!key)
					{
						FOR FIRST 1 P IN RDB$PROCEDURES
							WITH P.RDB$PROCEDURE_NAME EQ node.name->c_str() AND
								 P.RDB$PACKAGE_NAME MISSING
						{
							key = NO_GRANT_ON_PROC;
						}
						END_FOR
						ON_ERROR
							// Ignore any error
						END_ERROR
					}

					if (!key)
					{
						FOR FIRST 1 R IN RDB$ROLES
							WITH R.RDB$ROLE_NAME EQ node.name->c_str()
						{
							key = NO_GRANT_ON_ROL;
						}
						END_FOR
						ON_ERROR
							// Ignore any error
						END_ERROR
					}

					if (!key)
					{
						FOR FIRST 1 F IN RDB$FUNCTIONS
							WITH F.RDB$FUNCTION_NAME EQ node.name->c_str() AND
								 F.RDB$PACKAGE_NAME MISSING
						{
							key = NO_GRANT_ON_FUN;
						}
						END_FOR
						ON_ERROR
							// Ignore any error
						END_ERROR
					}

					if (!key)
					{
						FOR FIRST 1 G IN RDB$GENERATORS
							WITH G.RDB$GENERATOR_NAME EQ node.name->c_str()
						{
							key = NO_GRANT_ON_GEN;
						}
						END_FOR
						ON_ERROR
							// Ignore any error
						END_ERROR
					}

					if (!key)
					{
						FOR FIRST 1 E IN RDB$EXCEPTIONS
							WITH E.RDB$EXCEPTION_NAME EQ node.name->c_str()
						{
							key = NO_GRANT_ON_XCP;
						}
						END_FOR
						ON_ERROR
							// Ignore any error
						END_ERROR
					}

					if (!key)
					{
						FOR FIRST 1 F IN RDB$FIELDS
							WITH F.RDB$FIELD_NAME EQ node.name->c_str()
						{
							key = NO_GRANT_ON_FLD;
						}
						END_FOR
						ON_ERROR
							// Ignore any error
						END_ERROR
					}

					if (!key)
					{
						FOR FIRST 1 CS IN RDB$CHARACTER_SETS
							WITH CS.RDB$CHARACTER_SET_NAME EQ node.name->c_str()
						{
							key = NO_GRANT_ON_CS;
						}
						END_FOR
						ON_ERROR
							// Ignore any error
						END_ERROR
					}

					if (!key)
					{
						FOR FIRST 1 C IN RDB$COLLATIONS
							WITH C.RDB$COLLATION_NAME EQ node.name->c_str()
						{
							key = NO_GRANT_ON_COLL;
						}
						END_FOR
						ON_ERROR
							// Ignore any error
						END_ERROR
					}

					if (!key && isqlGlob.major_ods >= ODS_VERSION12)
					{
						FOR FIRST 1 P IN RDB$PACKAGES
							WITH P.RDB$PACKAGE_NAME EQ node.name->c_str()
						{
							key = NO_GRANT_ON_PKG;
						}
						END_FOR
						ON_ERROR
							// Ignore any error
						END_ERROR
					}

					if (!key)
						key = NO_OBJECT;

					notFoundName = node.name.value();
				}
				else
					key = NO_GRANT_ON_ANY;
			}

			return ret;
		},

		[&](const FrontendParser::ShowIndexesNode& node)
		{
			const auto ret = show_indices((node.name ? node.name->c_str() : ""));

			if (ret == OBJECT_NOT_FOUND)
			{
				if (node.name)
				{
					FOR FIRST 1 R IN RDB$RELATIONS
						WITH R.RDB$RELATION_NAME EQ node.name->c_str()
					{
						key = NO_INDICES_ON_REL;
					}
					END_FOR
					ON_ERROR
						// Ignore any error
					END_ERROR

					notFoundName = node.name.value();

					if (!key)
						key = NO_REL_OR_INDEX;
				}
				else
					key = NO_INDICES;
			}

			return ret;
		},

		[&](const FrontendParser::ShowMappingsNode& node)
		{
			const auto ret = SHOW_maps(false, (node.name ? node.name->c_str() : ""));

			if (ret == OBJECT_NOT_FOUND)
			{
				if (node.name)
				{
					key = NO_MAP;
					notFoundName = node.name.value();
				}
				else
					key = NO_MAPS;
			}

			return ret;
		},

		[&](const FrontendParser::ShowPackagesNode& node)
		{
			const auto ret = show_packages((node.name ? node.name->c_str() : ""), false);

			if (ret == OBJECT_NOT_FOUND)
			{
				if (node.name)
				{
					key = NO_PACKAGE;
					notFoundName = node.name.value();
				}
				else
					key = NO_PACKAGES;
			}

			return ret;
		},

		[&](const FrontendParser::ShowProceduresNode& node)
		{
			const auto ret = show_proc(
				(node.name ? node.name->c_str() : ""),
				(node.package ? node.package->c_str() : ""),
				false, false);

			if (ret == OBJECT_NOT_FOUND)
			{
				if (node.name)
				{
					key = NO_PROC;
					notFoundName = node.name.value();
				}
				else
					key = NO_PROCS;
			}

			return ret;
		},

		[&](const FrontendParser::ShowPublicationsNode& node)
		{
			const auto ret = show_publications((node.name ? node.name->c_str() : ""), false);

			if (ret == OBJECT_NOT_FOUND)
			{
				if (node.name)
				{
					key = NO_PUBLICATION;
					notFoundName = node.name.value();
				}
				else
					key = NO_PUBLICATIONS;
			}

			return ret;
		},

		[&](const FrontendParser::ShowRolesNode& node)
		{
			processing_state ret;

			if (isqlGlob.major_ods >= ODS_VERSION9)
			{
				if (node.name)
				{
					ret = show_role(node.name->c_str(), false);

					if (ret == OBJECT_NOT_FOUND)
					{
						key = NO_ROLE;
						notFoundName = node.name.value();
					}
				}
				else
				{
					ret = show_role(nullptr, false);
					if (ret == OBJECT_NOT_FOUND)
						key = NO_ROLES;
				}
			}
			else
			{
				ret = OBJECT_NOT_FOUND;
				key = NO_ROLES;
			}

			return ret;
		},

		[&](const FrontendParser::ShowSecClassesNode& node)
		{
			const auto ret = show_secclass(node.name, node.detail);

			if (ret == OBJECT_NOT_FOUND)
			{
				if (node.name)
				{
					key = NO_SECCLASS;
					notFoundName = node.name.value();
				}
				else
					key = NO_DB_WIDE_SECCLASS;
			}

			return ret;
		},

		[](const FrontendParser::ShowSqlDialectNode& node)
		{
			return show_dialect();
		},

		[](const FrontendParser::ShowSystemNode& node)
		{
			if (node.objType)
			{
				switch (node.objType.value())
				{
				case obj_collation:
					show_collations("", 1);
					break;

				case obj_udf:
					show_functions(nullptr, nullptr, false, true);
					break;

				case obj_relation:
					show_all_tables(1);
					break;

				case obj_sql_role:
					show_role(nullptr, true);
					break;

				case obj_procedure:
					show_proc(nullptr, nullptr, false, true);
					break;

				case obj_package_header:
					show_packages(nullptr, true);
					break;

				case obj_publication:
					show_publications(nullptr, true);
					break;

				default:
					return ps_ERR;
				}
			}
			else
			{
				TEXT msg[MSG_LENGTH];
				IUTILS_msg_get(MSG_TABLES, msg);
				isqlGlob.printf("%s%s", msg, NEWLINE);
				show_all_tables(1);
				IUTILS_msg_get(MSG_FUNCTIONS, msg);
				show_functions(nullptr, nullptr, false, true, msg);
				IUTILS_msg_get(MSG_PROCEDURES, msg);
				show_proc(nullptr, nullptr, false, true, msg);
				IUTILS_msg_get(MSG_PACKAGES, msg);
				show_packages(nullptr, true, msg);
				IUTILS_msg_get(MSG_COLLATIONS, msg);
				show_collations("", 1, msg, true);
				IUTILS_msg_get(MSG_ROLES, msg);
				show_role(nullptr, true, msg);
				IUTILS_msg_get(MSG_PUBLICATIONS, msg);
				show_publications(nullptr, true, msg);
			}

			return SKIP;
		},

		[&](const FrontendParser::ShowTablesNode& node)
		{
			processing_state ret;

			if (node.name)
			{
				ret = show_table(node.name->c_str(), false);

				if (ret == OBJECT_NOT_FOUND)
				{
					key = NO_TABLE;
					notFoundName = node.name.value();
				}
			}
			else
			{
				ret = show_all_tables(0);
				if (ret == OBJECT_NOT_FOUND)
					key = NO_TABLES;
			}

			return ret;
		},

		[&](const FrontendParser::ShowTriggersNode& node)
		{
			const auto ret = show_trigger((node.name ? node.name->c_str() : ""), true, true);

			if (ret == OBJECT_NOT_FOUND)
			{
				if (node.name)
				{
					key = NO_TRIGGER;
					notFoundName = node.name.value();
				}
				else
					key = NO_TRIGGERS;
			}

			return ret;
		},

		[&](const FrontendParser::ShowUsersNode& node)
		{
			const auto ret = show_users();

			if (ret == OBJECT_NOT_FOUND) // It seems impossible, but...
				key = NO_CONNECTED_USERS;

			return ret;
		},

		[](const FrontendParser::ShowVersionNode&)
		{
			TEXT msg_string[MSG_LENGTH];
			IUTILS_msg_get(VERSION, msg_string, SafeArg() << FB_VERSION);
			isqlGlob.printf("%s%s", msg_string, NEWLINE);
			isqlGlob.printf("Server version:%s", NEWLINE);
			VersionCallback callback;
			UtilInterfacePtr()->getFbVersion(fbStatus, DB, &callback);
			if (fbStatus->getState() & IStatus::STATE_ERRORS)
			{
				IUTILS_msg_get(CANNOT_GET_SRV_VER, msg_string);
				STDERROUT(msg_string);
			}

			return SKIP;
		},

		[&](const FrontendParser::ShowViewsNode& node)
		{
			processing_state ret;

			if (node.name)
			{
				ret = show_table(node.name->c_str(), true);

				if (ret == OBJECT_NOT_FOUND)
				{
					key = NO_VIEW;
					notFoundName = node.name.value();
				}
			}
			else
			{
				ret = show_all_tables(-1);
				if (ret == OBJECT_NOT_FOUND)
					key = NO_VIEWS;
			}

			return ret;
		},

		[](const FrontendParser::ShowWireStatsNode&)
		{
			return show_wireStats();
		},

		[](auto& arg)
		{
			static_assert(FrontendParser::AlwaysFalseV<decltype(arg)>,
				"Add visitor method for that show node type");
		}
	}, node);

	if (ret == OBJECT_NOT_FOUND)
	{
		TEXT key_string[MSG_LENGTH];
		IUTILS_msg_get(key, key_string, SafeArg() << notFoundName.c_str());
		STDERROUT(key_string);
	}

	return ret;
}


static void make_priv_string(USHORT flags, char* string, bool useAny)
{
/**************************************
 *
 *	m a k e _ p r i v _ s t r i n g
 *
 **************************************
 *
 * Functional description
 *	Given a bit-vector of privileges, turn it into a
 *	string list.
 *
 **************************************/
	if (flags == RELATION_PRIV_ALL)
	{
		strcat(string, "ALL");
		return;
	}

	for (int i = 0; privs[i].priv_string; i++)
	{
		if (flags & privs[i].priv_flag)
		{
			if (*string)
				strcat(string, ", ");

			strcat(string, privs[i].priv_string);

			if (useAny && (privs[i].priv_flag == priv_ALTER || privs[i].priv_flag == priv_DROP))
				strcat(string, " ANY");
		}
	}
}


static processing_state show_all_tables(SSHORT sys_flag)
{
/**************************************
 *
 *	s h o w _ a l l _ t a b l e s
 *
 **************************************
 *
 *	Print the names of all user tables from
 *	rdb$relations.  We use a dynamic query
 *
 *	Parameters:  sys_flag -- 0, show user tables
 *	1, show system tables only; -1, show views only
 *
 **************************************/
	bool first = true;

	if (sys_flag == -1)
	{
		// Views
		FOR REL IN RDB$RELATIONS WITH
			REL.RDB$VIEW_BLR NOT MISSING
			SORTED BY REL.RDB$RELATION_NAME
		{
			first = false;
			isqlGlob.printf("%s%s", fb_utils::exact_name(REL.RDB$RELATION_NAME), NEWLINE);
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR;
	}
	else // 23-Apr-2004 (only tables)
	{
		// The rdb$system_flag is not always set for non-system objects... this
		// query may potentially fail.
		FOR REL IN RDB$RELATIONS WITH
			(REL.RDB$SYSTEM_FLAG EQ sys_flag
				/*OR (sys_flag == 0 AND REL.RDB$SYSTEM_FLAG MISSING)*/)
			AND REL.RDB$VIEW_BLR MISSING
			SORTED BY REL.RDB$RELATION_NAME
		{
			first = false;
			isqlGlob.printf("%s%s", fb_utils::exact_name(REL.RDB$RELATION_NAME), NEWLINE);
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR;
	}

	if (!first)
	{
		isqlGlob.printf(NEWLINE);
		return SKIP;
	}

	return OBJECT_NOT_FOUND;
}


static void show_charsets(SSHORT char_set_id, SSHORT collation)
{
/*************************************
*
*	s h o w _ c h a r s e t s
*
**************************************
*
* Functional description
*	Show names of character set and collations
*
**************************************/
#ifdef	DEV_BUILD
	bool found = false;
#endif

	FOR COL IN RDB$COLLATIONS CROSS
		CST IN RDB$CHARACTER_SETS WITH
		COL.RDB$CHARACTER_SET_ID EQ CST.RDB$CHARACTER_SET_ID AND
		COL.RDB$COLLATION_ID EQ collation AND
		CST.RDB$CHARACTER_SET_ID EQ char_set_id

#ifdef DEV_BUILD
		found = true;
#endif
		fb_utils::exact_name(CST.RDB$CHARACTER_SET_NAME);
		fb_utils::exact_name(COL.RDB$COLLATION_NAME);
		fb_utils::exact_name(CST.RDB$DEFAULT_COLLATE_NAME);

		if (strcmp(CST.RDB$DEFAULT_COLLATE_NAME, COL.RDB$COLLATION_NAME) == 0 &&
			strcmp(CST.RDB$CHARACTER_SET_NAME, COL.RDB$COLLATION_NAME) == 0)
		{
			// Collation is default and match charset name - do not show it.
			isqlGlob.printf(" CHARACTER SET %s", CST.RDB$CHARACTER_SET_NAME);
		}
		else
		{
			isqlGlob.printf(" CHARACTER SET %s COLLATE %s", CST.RDB$CHARACTER_SET_NAME, COL.RDB$COLLATION_NAME);
		}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return;
	END_ERROR;
#ifdef DEV_BUILD
	if (!found)
	{
		TEXT Print_buffer[PRINT_BUFFER_LENGTH];
		sprintf(Print_buffer,
				"ISQL_get_character_set: charset %d collation %d not found.\n",
				char_set_id, collation);
		STDERROUT(Print_buffer);
	}
#endif
}


static processing_state show_check(const SCHAR* object)
{
/**************************************
 *
 *	s h o w _ c h e c k
 *
 **************************************
 *
 * Functional description
 *	Show check constraints for the named object
 *
 **************************************/
	bool first = true;

	if (!*object)
		return ps_ERR;
	// Query gets the check clauses for triggers stored for check constraints

	FOR TRG IN RDB$TRIGGERS CROSS
		CHK IN RDB$CHECK_CONSTRAINTS WITH
		TRG.RDB$TRIGGER_TYPE EQ 1 AND
		TRG.RDB$TRIGGER_NAME EQ CHK.RDB$TRIGGER_NAME AND
		//CHK.RDB$TRIGGER_NAME STARTING WITH "CHECK" AND
		TRG.RDB$SYSTEM_FLAG EQ int(fb_sysflag_check_constraint) AND
		TRG.RDB$RELATION_NAME EQ object
		SORTED BY CHK.RDB$CONSTRAINT_NAME

		// Use print_blob to print the blob
		first = false;

		isqlGlob.printf("CONSTRAINT %s:%s  ",
			fb_utils::exact_name(CHK.RDB$CONSTRAINT_NAME), NEWLINE);

		if (!TRG.RDB$TRIGGER_SOURCE.NULL)
			SHOW_print_metadata_text_blob (isqlGlob.Out, &TRG.RDB$TRIGGER_SOURCE);
		isqlGlob.printf(NEWLINE);

	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR;
	if (first)
		return (OBJECT_NOT_FOUND);
	return (SKIP);
}


static processing_state show_collations(const SCHAR* object, SSHORT sys_flag, const char* msg, bool compact)
{
/**************************************
 *
 *	s h o w _ c o l l a t i o n s
 *
 **************************************
 *
 * Functional description
 *	Show collations.
 *
 **************************************/
	bool found = false;

	// Show all collations or named collation
	FOR CL IN RDB$COLLATIONS CROSS
		CS IN RDB$CHARACTER_SETS WITH
		CS.RDB$CHARACTER_SET_ID EQ CL.RDB$CHARACTER_SET_ID
		SORTED BY CL.RDB$COLLATION_NAME

		fb_utils::exact_name(CL.RDB$COLLATION_NAME);

		if ((!*object &&
			 ((!CL.RDB$SYSTEM_FLAG.NULL && CL.RDB$SYSTEM_FLAG != 0 && sys_flag != 0) ||
			  (!(!CL.RDB$SYSTEM_FLAG.NULL && CL.RDB$SYSTEM_FLAG != 0) && sys_flag != 1))) ||
			strcmp(CL.RDB$COLLATION_NAME, object) == 0)
		{
			if (!found)
			{
				found = true;

				if (msg)
					isqlGlob.printf("%s%s", msg, NEWLINE);
			}

			if (compact)
				isqlGlob.printf("%s%s", CL.RDB$COLLATION_NAME, NEWLINE);
			else
			{
				isqlGlob.printf("%s", CL.RDB$COLLATION_NAME);

				fb_utils::exact_name(CS.RDB$CHARACTER_SET_NAME);
				isqlGlob.printf(", CHARACTER SET %s", CS.RDB$CHARACTER_SET_NAME);

				if (!CL.RDB$BASE_COLLATION_NAME.NULL)
				{
					fb_utils::exact_name(CL.RDB$BASE_COLLATION_NAME);
					isqlGlob.printf(", FROM EXTERNAL ('%s')", CL.RDB$BASE_COLLATION_NAME);
				}

				if (!CL.RDB$COLLATION_ATTRIBUTES.NULL)
				{
					if (CL.RDB$COLLATION_ATTRIBUTES & TEXTTYPE_ATTR_PAD_SPACE)
						isqlGlob.printf(", PAD SPACE");

					if (CL.RDB$COLLATION_ATTRIBUTES & TEXTTYPE_ATTR_CASE_INSENSITIVE)
						isqlGlob.printf(", CASE INSENSITIVE");

					if (CL.RDB$COLLATION_ATTRIBUTES & TEXTTYPE_ATTR_ACCENT_INSENSITIVE)
						isqlGlob.printf(", ACCENT INSENSITIVE");
				}

				if (!CL.RDB$SPECIFIC_ATTRIBUTES.NULL)
				{
					isqlGlob.printf(", '");
					SHOW_print_metadata_text_blob (isqlGlob.Out, &CL.RDB$SPECIFIC_ATTRIBUTES);
					isqlGlob.printf("'");
				}

				if (!CL.RDB$SYSTEM_FLAG.NULL && CL.RDB$SYSTEM_FLAG != 0)
					isqlGlob.printf(", SYSTEM");

				isqlGlob.printf("%s", NEWLINE);
			}
		}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR;

	if (!found)
		return (OBJECT_NOT_FOUND);

	isqlGlob.printf(NEWLINE);

	return SKIP;
}


// ***********************
// s h o w _ c o m m e n t
// ***********************
// Helper that displays in correct syntax the COMMENT ON command for each object.
// It escapes identifiers with embedded double quotes and escapes the comment
// itself if it contains single quotes when we are honoring script extraction.
static void show_comment(const char* objtype, char* packageName, char* name1, char* name2,
	ISC_QUAD* blobfld, const commentMode showextract, const char* banner)
{
	const bool escape_quotes = showextract == cmmExtract;

	if (escape_quotes && banner)
		isqlGlob.prints(banner);

	if (packageName)
		fb_utils::exact_name(packageName);
	if (name1)
		fb_utils::exact_name(name1);
	if (name2)
		fb_utils::exact_name(name2);

	char packageNameBuffer[BUFFER_LENGTH256];
	char SQL_identifier2[BUFFER_LENGTH256];

	if (escape_quotes && isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
	{
		if (packageName)
		{
			IUTILS_copy_SQL_id (packageName, packageNameBuffer, DBL_QUOTE);
			packageName = packageNameBuffer;
		}

		if (name1)
		{
			IUTILS_copy_SQL_id (name1, SQL_identifier, DBL_QUOTE);
			name1 = SQL_identifier;
		}

		if (name2)
		{
			IUTILS_copy_SQL_id (name2, SQL_identifier2, DBL_QUOTE);
			name2 = SQL_identifier2;
		}
	}

	const char* quot = escape_quotes ? "'" : "";

	isqlGlob.printf("COMMENT ON %-12s", objtype);

	if (packageName || name1 || name2)
		isqlGlob.printf(" ");

	if (packageName)
		isqlGlob.printf("%s.", packageName);

	if (name1)
		isqlGlob.printf("%s", name1);

	if (name2)
		isqlGlob.printf(".%s", name2);

	isqlGlob.printf(" IS %s", quot);

	SHOW_print_metadata_text_blob(isqlGlob.Out, blobfld, escape_quotes);
	isqlGlob.printf("%s%s%s", quot, isqlGlob.global_Term, NEWLINE);
}


// *************************
// s h o w _ c o m m e n t s
// *************************
// Will extract and show descriptions (comments) for all supported db objects.
// This function does its task even if the server version doesn't support
// the COMMENT ON command. It will however skip generators and roles that
// didn't have description fields before ODS11.
// It will extract the main objects by category and inside each category,
// in alphabetical order. For tables and views, their fields are printed
// immediately after the table/field in rdb$field_position order, that's
// the order the users sees when doing a select * from tbl/view. For procedures,
// their parameters are printed immediately after the procedure, first the input
// params by position, the  the output params by position. All system objects
// as well as implicit domains and implicit triggers are skipped. For ODS < 11,
// we skip generators and roles because those system tables didn't have a
// rdb$description field.
// When showing comments, we don't escape quotes in neither names nor strings.
// When extracting comments, we do the usual escaping to make the script valid.
static processing_state show_comments(const commentMode showextract, const char* banner)
{
	// From dsql.h:
	//	ddl_database, ddl_domain, ddl_relation, ddl_view, ddl_procedure, ddl_trigger,
	//	ddl_udf, ddl_blob_filter, ddl_exception, ddl_generator, ddl_index, ddl_role,
	//	ddl_charset, ddl_collation//, ddl_sec_class

	bool first = true;

	FOR FIRST 1 DT IN RDB$DATABASE
		WITH DT.RDB$DESCRIPTION NOT MISSING

		show_comment("DATABASE", NULL, NULL, NULL, &DT.RDB$DESCRIPTION, showextract, first ? banner : 0);
		first = false;
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	FOR DM IN RDB$FIELDS
	WITH DM.RDB$FIELD_NAME NOT MATCHING "RDB$+" USING "+=[0-9][0-9]* *"
		AND (DM.RDB$SYSTEM_FLAG EQ 0 OR DM.RDB$SYSTEM_FLAG MISSING)
		AND DM.RDB$DESCRIPTION NOT MISSING
		SORTED BY DM.RDB$FIELD_NAME

		show_comment("DOMAIN", NULL, DM.RDB$FIELD_NAME, NULL, &DM.RDB$DESCRIPTION,
			showextract, first ? banner : 0);
		first = false;
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	FOR RL IN RDB$RELATIONS
		WITH RL.RDB$VIEW_BLR MISSING
		AND (RL.RDB$SYSTEM_FLAG EQ 0 OR RL.RDB$SYSTEM_FLAG MISSING)
		SORTED BY RL.RDB$RELATION_NAME

		if (!RL.RDB$DESCRIPTION.NULL && !UserBlob::blobIsNull(RL.RDB$DESCRIPTION))
		{
			show_comment("TABLE", NULL, RL.RDB$RELATION_NAME, NULL, &RL.RDB$DESCRIPTION,
				showextract, first ? banner : 0);
			first = false;
		}

		FOR RF IN RDB$RELATION_FIELDS
			WITH RF.RDB$RELATION_NAME = RL.RDB$RELATION_NAME
			AND RF.RDB$DESCRIPTION NOT MISSING
			SORTED BY RF.RDB$FIELD_POSITION

			show_comment("   COLUMN", NULL, RL.RDB$RELATION_NAME, RF.RDB$FIELD_NAME,
				&RF.RDB$DESCRIPTION, showextract, first ? banner : 0);
			first = false;
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR

	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	FOR VW IN RDB$RELATIONS
		WITH VW.RDB$VIEW_BLR NOT MISSING
		AND (VW.RDB$SYSTEM_FLAG EQ 0 OR VW.RDB$SYSTEM_FLAG MISSING)
		SORTED BY VW.RDB$RELATION_NAME

		if (!VW.RDB$DESCRIPTION.NULL && !UserBlob::blobIsNull(VW.RDB$DESCRIPTION))
		{
			show_comment("VIEW", NULL, VW.RDB$RELATION_NAME, NULL, &VW.RDB$DESCRIPTION,
				showextract, first ? banner : 0);
			first = false;
		}

		FOR RF IN RDB$RELATION_FIELDS
			WITH RF.RDB$RELATION_NAME = VW.RDB$RELATION_NAME
			AND RF.RDB$DESCRIPTION NOT MISSING
			SORTED BY RF.RDB$FIELD_POSITION

			show_comment("   COLUMN", NULL, VW.RDB$RELATION_NAME, RF.RDB$FIELD_NAME,
				&RF.RDB$DESCRIPTION, showextract, first ? banner : 0);
			first = false;
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR

	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	FOR PR IN RDB$PROCEDURES
		WITH (PR.RDB$SYSTEM_FLAG EQ 0 OR PR.RDB$SYSTEM_FLAG MISSING)
		SORTED BY PR.RDB$PROCEDURE_NAME

		if (!PR.RDB$DESCRIPTION.NULL && !UserBlob::blobIsNull(PR.RDB$DESCRIPTION))
		{
			show_comment("PROCEDURE", (PR.RDB$PACKAGE_NAME.NULL ? NULL : PR.RDB$PACKAGE_NAME),
				PR.RDB$PROCEDURE_NAME, NULL, &PR.RDB$DESCRIPTION, showextract, first ? banner : 0);
			first = false;
		}

		FOR PA IN RDB$PROCEDURE_PARAMETERS
			WITH PA.RDB$PROCEDURE_NAME = PR.RDB$PROCEDURE_NAME
			AND PA.RDB$PACKAGE_NAME EQUIV NULLIF(PR.RDB$PACKAGE_NAME, '')
			AND PA.RDB$DESCRIPTION NOT MISSING
			SORTED BY PA.RDB$PARAMETER_TYPE, PA.RDB$PARAMETER_NUMBER

			show_comment("   PROCEDURE PARAMETER",
				(PR.RDB$PACKAGE_NAME.NULL ? NULL : PR.RDB$PACKAGE_NAME), PR.RDB$PROCEDURE_NAME,
				PA.RDB$PARAMETER_NAME, &PA.RDB$DESCRIPTION, showextract, first ? banner : 0);
			first = false;
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR

	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	FOR TR IN RDB$TRIGGERS
		WITH TR.RDB$DESCRIPTION NOT MISSING
		AND (TR.RDB$SYSTEM_FLAG EQ 0 OR TR.RDB$SYSTEM_FLAG MISSING)
		SORTED BY TR.RDB$TRIGGER_NAME

		show_comment("TRIGGER", NULL, TR.RDB$TRIGGER_NAME, NULL, &TR.RDB$DESCRIPTION,
			showextract, first ? banner : 0);
		first = false;
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	FOR UD IN RDB$FUNCTIONS
		WITH UD.RDB$DESCRIPTION NOT MISSING
		AND (UD.RDB$SYSTEM_FLAG EQ 0 OR UD.RDB$SYSTEM_FLAG MISSING)
		SORTED BY UD.RDB$FUNCTION_NAME

		// Avoid syntax error when extracting scripts due to an historical bug in gbak.
		// See CORE-1174.
		if (UserBlob::blobIsNull(UD.RDB$DESCRIPTION))
			continue;

		show_comment("FUNCTION",
			(UD.RDB$PACKAGE_NAME.NULL ? NULL : UD.RDB$PACKAGE_NAME), UD.RDB$FUNCTION_NAME, NULL,
			&UD.RDB$DESCRIPTION, showextract, first ? banner : 0);
		first = false;

		FOR ARG IN RDB$FUNCTION_ARGUMENTS
			WITH ARG.RDB$FUNCTION_NAME = UD.RDB$FUNCTION_NAME
			AND ARG.RDB$PACKAGE_NAME EQUIV NULLIF(UD.RDB$PACKAGE_NAME, '')
			AND ARG.RDB$DESCRIPTION NOT MISSING
			SORTED BY ARG.RDB$ARGUMENT_POSITION

			show_comment("   FUNCTION PARAMETER",
				(ARG.RDB$PACKAGE_NAME.NULL ? NULL : ARG.RDB$PACKAGE_NAME), ARG.RDB$FUNCTION_NAME,
				ARG.RDB$ARGUMENT_NAME, &ARG.RDB$DESCRIPTION, showextract, first ? banner : 0);
			first = false;
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	FOR BF IN RDB$FILTERS
		WITH BF.RDB$DESCRIPTION NOT MISSING
		AND (BF.RDB$SYSTEM_FLAG EQ 0 OR BF.RDB$SYSTEM_FLAG MISSING)
		SORTED BY BF.RDB$FUNCTION_NAME

		show_comment("FILTER", NULL, BF.RDB$FUNCTION_NAME, NULL, &BF.RDB$DESCRIPTION,
			showextract, first ? banner : 0);
		first = false;
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	FOR XC IN RDB$EXCEPTIONS
		WITH XC.RDB$DESCRIPTION NOT MISSING
		AND (XC.RDB$SYSTEM_FLAG EQ 0 OR XC.RDB$SYSTEM_FLAG MISSING)
		SORTED BY XC.RDB$EXCEPTION_NAME

		show_comment("EXCEPTION", NULL, XC.RDB$EXCEPTION_NAME, NULL, &XC.RDB$DESCRIPTION,
			showextract, first ? banner : 0);
		first = false;
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	if (isqlGlob.major_ods >= ODS_VERSION11)
	{
		FOR GR IN RDB$GENERATORS
			WITH GR.RDB$DESCRIPTION NOT MISSING
			AND (GR.RDB$SYSTEM_FLAG EQ 0 OR GR.RDB$SYSTEM_FLAG MISSING)
			SORTED BY GR.RDB$GENERATOR_NAME

			show_comment("GENERATOR", NULL, GR.RDB$GENERATOR_NAME, NULL, &GR.RDB$DESCRIPTION,
				showextract, first ? banner : 0);
			first = false;
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR
	}

	FOR IX IN RDB$INDICES
		WITH IX.RDB$DESCRIPTION NOT MISSING
		AND (IX.RDB$SYSTEM_FLAG EQ 0 OR IX.RDB$SYSTEM_FLAG MISSING)
		SORTED BY IX.RDB$INDEX_NAME

		show_comment("INDEX", NULL, IX.RDB$INDEX_NAME, NULL, &IX.RDB$DESCRIPTION,
			showextract, first ? banner : 0);
		first = false;
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	if (isqlGlob.major_ods >= ODS_VERSION11)
	{
		FOR RO IN RDB$ROLES
			WITH RO.RDB$DESCRIPTION NOT MISSING
			AND (RO.RDB$SYSTEM_FLAG EQ 0 OR RO.RDB$SYSTEM_FLAG MISSING)
			SORTED BY RO.RDB$ROLE_NAME

			show_comment("ROLE", NULL, RO.RDB$ROLE_NAME, NULL, &RO.RDB$DESCRIPTION,
				showextract, first ? banner : 0);
			first = false;
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR
	}

	if (isqlGlob.major_ods >= ODS_VERSION12)
	{
		FOR PACK IN RDB$PACKAGES
			WITH PACK.RDB$DESCRIPTION NOT MISSING
			AND (PACK.RDB$SYSTEM_FLAG EQ 0 OR PACK.RDB$SYSTEM_FLAG MISSING)
			SORTED BY PACK.RDB$PACKAGE_NAME

			show_comment("PACKAGE", NULL, PACK.RDB$PACKAGE_NAME, NULL, &PACK.RDB$DESCRIPTION,
				showextract, first ? banner : 0);
			first = false;
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR
	}

	FOR CH IN RDB$CHARACTER_SETS
		WITH CH.RDB$DESCRIPTION NOT MISSING
		AND (CH.RDB$SYSTEM_FLAG EQ 0 OR CH.RDB$SYSTEM_FLAG MISSING)
		SORTED BY CH.RDB$CHARACTER_SET_NAME

		show_comment("CHARACTER SET", NULL, CH.RDB$CHARACTER_SET_NAME, NULL,
			&CH.RDB$DESCRIPTION, showextract, first ? banner : 0);
		first = false;
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	FOR CL IN RDB$COLLATIONS
		WITH CL.RDB$DESCRIPTION NOT MISSING
		AND (CL.RDB$SYSTEM_FLAG EQ 0 OR CL.RDB$SYSTEM_FLAG MISSING)
		SORTED BY CL.RDB$COLLATION_NAME

		show_comment("COLLATION", NULL, CL.RDB$COLLATION_NAME, NULL, &CL.RDB$DESCRIPTION,
			showextract, first ? banner : 0);
		first = false;
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	if (isqlGlob.major_ods >= ODS_VERSION12)
	{
		FOR PACK IN RDB$PACKAGES
			WITH PACK.RDB$DESCRIPTION NOT MISSING
			AND (PACK.RDB$SYSTEM_FLAG EQ 0 OR PACK.RDB$SYSTEM_FLAG MISSING)
			SORTED BY PACK.RDB$PACKAGE_NAME

			show_comment("PACKAGE", NULL, PACK.RDB$PACKAGE_NAME, NULL, &PACK.RDB$DESCRIPTION,
				showextract, first ? banner : 0);
			first = false;
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR

		FOR M IN RDB$AUTH_MAPPING
			WITH M.RDB$DESCRIPTION NOT MISSING
			AND (M.RDB$SYSTEM_FLAG EQ 0 OR M.RDB$SYSTEM_FLAG MISSING)
			SORTED BY M.RDB$MAP_NAME

			show_comment("MAPPING", NULL, M.RDB$MAP_NAME, NULL, &M.RDB$DESCRIPTION,
				showextract, first ? banner : 0);
			first = false;
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR

		FOR M IN SEC$GLOBAL_AUTH_MAPPING
			WITH M.SEC$DESCRIPTION NOT MISSING
			SORTED BY M.SEC$MAP_NAME

			show_comment("GLOBAL MAPPING", NULL, M.SEC$MAP_NAME, NULL, &M.SEC$DESCRIPTION,
				showextract, first ? banner : 0);
			first = false;
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR
	}
	return first ? OBJECT_NOT_FOUND : SKIP;
}


static void show_db()
{
/**************************************
 *
 *	s h o w _ d b
 *
 **************************************
 *
 * Functional description
 *	Show info on this database.  cache, logfiles, etc
 *
 **************************************/

	// First print the name of the database

	isqlGlob.printf("Database: %s%s", isqlGlob.global_Db_name, NEWLINE);
	// Get the owner name
	FOR REL IN RDB$RELATIONS WITH
		REL.RDB$RELATION_NAME = "RDB$DATABASE"

		if (!REL.RDB$OWNER_NAME.NULL) {
			isqlGlob.printf("%sOwner: %s%s", TAB_AS_SPACES, REL.RDB$OWNER_NAME, NEWLINE);
		}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return;
	END_ERROR;

	// Query for files

	FOR FIL IN RDB$FILES
		SORTED BY FIL.RDB$SHADOW_NUMBER, FIL.RDB$FILE_SEQUENCE

		// reset nulls to zero

		if (FIL.RDB$FILE_FLAGS.NULL)
			FIL.RDB$FILE_FLAGS = 0;
		if (FIL.RDB$FILE_LENGTH.NULL)
			FIL.RDB$FILE_LENGTH = 0;
		if (FIL.RDB$FILE_SEQUENCE.NULL)
			FIL.RDB$FILE_SEQUENCE = 0;
		if (FIL.RDB$FILE_START.NULL)
			FIL.RDB$FILE_START = 0;
		if (!FIL.RDB$FILE_NAME.NULL)
			fb_utils::exact_name(FIL.RDB$FILE_NAME);

		if (FIL.RDB$FILE_FLAGS == 0)
		{
			isqlGlob.printf(" File %d: \"%s\", length %ld, start %ld%s",
					 FIL.RDB$FILE_SEQUENCE, FIL.RDB$FILE_NAME,
					 FIL.RDB$FILE_LENGTH, FIL.RDB$FILE_START, NEWLINE);
		}
		else if (FIL.RDB$FILE_FLAGS & FILE_shadow)
		{
			if (FIL.RDB$FILE_SEQUENCE) {
				isqlGlob.printf("%sfile %s ", TAB_AS_SPACES, FIL.RDB$FILE_NAME);
			}
			else
			{
				isqlGlob.printf(" Shadow %d: \"%s\" ", FIL.RDB$SHADOW_NUMBER, FIL.RDB$FILE_NAME);
				if (FIL.RDB$FILE_FLAGS & FILE_inactive) {
					isqlGlob.printf("inactive ");
				}
				if (FIL.RDB$FILE_FLAGS & FILE_manual) {
					isqlGlob.printf("manual ");
				}
				else {
					isqlGlob.printf("auto ");
				}
				if (FIL.RDB$FILE_FLAGS & FILE_conditional) {
					isqlGlob.printf("conditional ");
				}
			}
			if (FIL.RDB$FILE_LENGTH) {
				isqlGlob.printf("length %ld ", FIL.RDB$FILE_LENGTH);
			}
			if (FIL.RDB$FILE_START) {
				isqlGlob.printf("starting %ld", FIL.RDB$FILE_START);
			}
			isqlGlob.printf(NEWLINE);
		}
		else if ((FIL.RDB$FILE_FLAGS & FILE_difference) && !FIL.RDB$FILE_NAME.NULL)
		{
			// This is an explicit name for the difference file typically named <db_name>.delta
			isqlGlob.printf("Explicit physical backup difference file: \"%s\"%s",
					FIL.RDB$FILE_NAME, NEWLINE);
		}

	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return;
	END_ERROR;

	// First general database parameters

	bool translate = true;

	SHOW_dbb_parameters(DB, db_items, sizeof(db_items), translate, NEWLINE);

	FOR DBB IN RDB$DATABASE
		CROSS CS IN RDB$CHARACTER_SETS
		WITH CS.RDB$CHARACTER_SET_NAME EQ DBB.RDB$CHARACTER_SET_NAME

		fb_utils::exact_name(DBB.RDB$CHARACTER_SET_NAME);
		fb_utils::exact_name(CS.RDB$DEFAULT_COLLATE_NAME);

		isqlGlob.printf("Default Character set: %s", DBB.RDB$CHARACTER_SET_NAME);

		if (!CS.RDB$DEFAULT_COLLATE_NAME.NULL &&
			strcmp(CS.RDB$DEFAULT_COLLATE_NAME, DBB.RDB$CHARACTER_SET_NAME) != 0)
		{
			isqlGlob.printf(" (with Default Collation %s)", CS.RDB$DEFAULT_COLLATE_NAME);
		}

		isqlGlob.printf("%s", NEWLINE);
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return;
	END_ERROR;

	int pass = 0;
	FOR DBB2 IN RDB$DATABASE

		if (!DBB2.RDB$LINGER.NULL && DBB2.RDB$LINGER > 0)
			isqlGlob.printf("Linger: %d seconds%s", DBB2.RDB$LINGER, NEWLINE);

		if (!DBB2.RDB$SQL_SECURITY.NULL && DBB2.RDB$SQL_SECURITY == FB_TRUE)
			isqlGlob.printf("SQL SECURITY DEFINER%s", NEWLINE);

		if (++pass > 1)
			isqlGlob.printf("RDB$DATABASE has more than one record%s", NEWLINE);

	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return;
	END_ERROR;

	if (isqlGlob.major_ods >= ODS_VERSION13)
	{
		bool published = false;

		FOR PUB IN RDB$PUBLICATIONS WITH
			PUB.RDB$ACTIVE_FLAG > 0

			published = true;
			break;

		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return;
		END_ERROR;

		isqlGlob.printf("Publication: %s%s", published ? "Enabled" : "Disabled", NEWLINE);
	}
}


// *********************************
// s h o w _ d e p e n d e n c i e s   (front-end)
// *********************************
// Iterate through all types of objects types (as per jrd/obj.h) calling the
// overloaded routine. We try to fetch all possible object types that share
// the same name.
static processing_state show_dependencies(const char* object)
{
	if (!object || !object[0])
		return ps_ERR;

	bool missing = true;

	for (FB_SIZE_T i = 0; i < FB_NELEM(Object_types); ++i)
	{
		if (show_dependencies(object, i) == SKIP)
		{
			missing = false;
			isqlGlob.printf("+++%s", NEWLINE);
		}
	}

	return missing ? OBJECT_NOT_FOUND : SKIP;
}


// *********************************
// s h o w _ d e p e n d e n c i e s    (processor)
// *********************************
// Discover dependencies. Format:
// - objects that depend on this object
// - objects this object depends on
// - if it's table or view, list fields that depend on other objects
// - if it's procedure, list parameters that depend on other objects (unlikely for now)
static processing_state show_dependencies(const char* object, int obj_type)
{
	bool missing1 = true;

	FOR DEP1 IN RDB$DEPENDENCIES
		WITH DEP1.RDB$DEPENDED_ON_NAME EQ object AND
			 DEP1.RDB$DEPENDED_ON_TYPE EQ obj_type
		if (missing1)
			missing1 = false;
		else
			isqlGlob.prints(", ");

		fb_utils::exact_name(DEP1.RDB$DEPENDENT_NAME);
		const char* type_name = Object_types[DEP1.RDB$DEPENDENT_TYPE];
		if (DEP1.RDB$FIELD_NAME.NULL)
			isqlGlob.printf("%s:%s", DEP1.RDB$DEPENDENT_NAME, type_name);
		else
		{
			fb_utils::exact_name(DEP1.RDB$FIELD_NAME);
			isqlGlob.printf("%s:%s->%s", DEP1.RDB$DEPENDENT_NAME, type_name, DEP1.RDB$FIELD_NAME);
		}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR;

	bool target_done = false;
	if (!missing1)
	{
		const char* type_name = Object_types[obj_type];
		isqlGlob.printf("%s%s[%s:%s]", NEWLINE, TAB_AS_SPACES, object, type_name);
		target_done = true;
	}

	bool missing2 = true;

	FOR DEP2 IN RDB$DEPENDENCIES
		WITH DEP2.RDB$DEPENDENT_NAME EQ object AND
			 DEP2.RDB$DEPENDENT_TYPE EQ obj_type
		if (missing2)
		{
			if (!target_done)
			{
				const char* type_name = Object_types[obj_type];
				isqlGlob.printf("%s[%s:%s]", TAB_AS_SPACES, object, type_name);
				target_done = true;
			}

			isqlGlob.prints(NEWLINE);
			missing2 = false;
		}
		else
			isqlGlob.prints(", ");

		fb_utils::exact_name(DEP2.RDB$DEPENDED_ON_NAME);
		const char* type_name = Object_types[DEP2.RDB$DEPENDED_ON_TYPE];
		if (DEP2.RDB$FIELD_NAME.NULL)
			isqlGlob.printf("%s:%s", DEP2.RDB$DEPENDED_ON_NAME, type_name);
		else
		{
			fb_utils::exact_name(DEP2.RDB$FIELD_NAME);
			isqlGlob.printf("%s:%s<-%s", DEP2.RDB$DEPENDED_ON_NAME, type_name, DEP2.RDB$FIELD_NAME);
		}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR;

	bool is_table = false;

	FOR REL IN RDB$RELATIONS
		WITH REL.RDB$RELATION_NAME = object AND
			 REL.RDB$VIEW_BLR MISSING AND
			 (REL.RDB$DBKEY_LENGTH MISSING OR REL.RDB$DBKEY_LENGTH = 8)
		is_table = true;
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR;

	bool missing3 = true;
	if ((obj_type == obj_relation && is_table) || (obj_type == obj_view && !is_table))
	{
		FOR RFR IN RDB$RELATION_FIELDS
			CROSS FLD IN RDB$FIELDS
			CROSS DEP3 IN RDB$DEPENDENCIES
			WITH RFR.RDB$RELATION_NAME = object AND
				 RFR.RDB$FIELD_SOURCE = FLD.RDB$FIELD_NAME AND
				 DEP3.RDB$DEPENDENT_NAME = RFR.RDB$FIELD_SOURCE AND
				 DEP3.RDB$DEPENDENT_TYPE EQ obj_computed
			SORTED BY RFR.RDB$FIELD_POSITION

			if (FLD.RDB$COMPUTED_BLR.NULL) // redundant
				continue;

			if (missing3)
			{
				if (!target_done)
				{
					const char* type_name = Object_types[obj_type];
					isqlGlob.printf("%s[%s:%s]", TAB_AS_SPACES, object, type_name);
					target_done = true;
				}

				isqlGlob.prints(NEWLINE);
				missing3 = false;
			}
			else
				isqlGlob.prints(", ");

			fb_utils::exact_name(RFR.RDB$FIELD_NAME);
			fb_utils::exact_name(FLD.RDB$FIELD_NAME);
			fb_utils::exact_name(DEP3.RDB$DEPENDED_ON_NAME);
			const char* type_name = Object_types[DEP3.RDB$DEPENDED_ON_TYPE];
			isqlGlob.printf("Field-%s(%s):%s->%s:%s", RFR.RDB$FIELD_NAME, FLD.RDB$FIELD_NAME,
				Object_types[obj_computed], DEP3.RDB$DEPENDED_ON_NAME, type_name);
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR;
	}
	else if (obj_type == obj_procedure)
	{
		// This code shouldn't find anything under normal circumstances.
		FOR PAR IN RDB$PROCEDURE_PARAMETERS
			CROSS FLD IN RDB$FIELDS
			CROSS DEP3 IN RDB$DEPENDENCIES
			WITH PAR.RDB$PROCEDURE_NAME = object AND
				 PAR.RDB$FIELD_SOURCE = FLD.RDB$FIELD_NAME AND
				 DEP3.RDB$DEPENDENT_NAME = PAR.RDB$FIELD_SOURCE AND
				 DEP3.RDB$DEPENDENT_TYPE EQ obj_computed
			SORTED BY PAR.RDB$PARAMETER_TYPE, PAR.RDB$PARAMETER_NUMBER
			if (FLD.RDB$COMPUTED_BLR.NULL) // redundant
				continue;

			if (missing3)
			{
				if (!target_done)
				{
					const char* type_name = Object_types[obj_type];
					isqlGlob.printf("%s[%s:%s]", TAB_AS_SPACES, object, type_name);
					target_done = true;
				}

				isqlGlob.prints(NEWLINE);
				missing3 = false;
			}
			else
				isqlGlob.prints(", ");

			fb_utils::exact_name(PAR.RDB$PARAMETER_NAME);
			fb_utils::exact_name(FLD.RDB$FIELD_NAME);
			fb_utils::exact_name(DEP3.RDB$DEPENDED_ON_NAME);
			const char* type_name = Object_types[DEP3.RDB$DEPENDED_ON_TYPE];
			isqlGlob.printf("%s-%s(%s):%s->%s:%s", PAR.RDB$PARAMETER_TYPE ? "Output" : "Input",
				PAR.RDB$PARAMETER_NAME, FLD.RDB$FIELD_NAME,
				Object_types[obj_computed], DEP3.RDB$DEPENDED_ON_NAME, type_name);
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR;
	}


	if (!target_done)
		return OBJECT_NOT_FOUND;

	isqlGlob.prints(NEWLINE);
	return SKIP;
}


static processing_state show_dialect()
{
/**************************************
 *
 *	s h o w _ d i a l e c t
 *
 **************************************
 *
 *	Print out the SQL dialect information
 *
 **************************************/

	if (isqlGlob.db_SQL_dialect > 0)
	{
		isqlGlob.printf("%38s%d%s%d",
				"Client SQL dialect is set to: ", isqlGlob.SQL_dialect,
				" and database SQL dialect is: ", isqlGlob.db_SQL_dialect);
	}
	else if (isqlGlob.SQL_dialect == 0)
	{
		isqlGlob.printf("%38s%s",
				"Client SQL dialect has not been set",
				" and no database has been connected yet.");
	}
	else
	{
		isqlGlob.printf("%38s%d%s",
				"Client SQL dialect is set to: ", isqlGlob.SQL_dialect,
				". No database has been connected.");
	}
	isqlGlob.printf(NEWLINE);
	return SKIP;
}


static processing_state show_domains(const SCHAR* domain_name)
{
/*************************************
*
*	s h o w _ d o m a i n s
*
**************************************
*
* Functional description
*	Show all domains or the named domain
************************************/
	bool first = true;

	if (!*domain_name)
	{
		//  List all domain names in columns
		FOR FLD IN RDB$FIELDS WITH
			FLD.RDB$FIELD_NAME NOT MATCHING "RDB$+" USING "+=[0-9][0-9]* *"
			AND FLD.RDB$SYSTEM_FLAG NE 1
			SORTED BY FLD.RDB$FIELD_NAME

			first = false;
			isqlGlob.printf("%s%s", fb_utils::exact_name(FLD.RDB$FIELD_NAME), NEWLINE);
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR;
		if (!first)
			isqlGlob.printf(NEWLINE);
	}
	else
	{
		// List named domain

		FOR FLD IN RDB$FIELDS WITH
			FLD.RDB$FIELD_NAME EQ domain_name;

			first = false;
			// Print the name of the domain
			fb_utils::exact_name(FLD.RDB$FIELD_NAME);
			isqlGlob.printf("%-31s ", FLD.RDB$FIELD_NAME);

			// Array dimensions
			if (!FLD.RDB$DIMENSIONS.NULL)
			{
				isqlGlob.printf("ARRAY OF ");
				ISQL_array_dimensions (FLD.RDB$FIELD_NAME);
				isqlGlob.printf("%s                                ", NEWLINE);
			}

			if (!ISQL_printNumericType(FLD.RDB$FIELD_NAME, FLD.RDB$FIELD_TYPE, FLD.RDB$FIELD_SUB_TYPE,
					FLD.RDB$FIELD_PRECISION, FLD.RDB$FIELD_SCALE))
			{
				return ps_ERR;
			}

			// Length for CHARs
			if ((FLD.RDB$FIELD_TYPE == blr_text) || (FLD.RDB$FIELD_TYPE == blr_varying)) {
				isqlGlob.printf("(%d)", ISQL_get_field_length(FLD.RDB$FIELD_NAME));
			}

			// Blob domains
			if (FLD.RDB$FIELD_TYPE == blr_blob)
			{
				isqlGlob.printf(" segment %u, subtype ", (USHORT) FLD.RDB$SEGMENT_LENGTH);
				const int subtype  = FLD.RDB$FIELD_SUB_TYPE;
				if (subtype >= 0 && subtype <= MAX_BLOBSUBTYPES) {
					isqlGlob.prints(Sub_types[subtype]);
				}
				else {
					isqlGlob.printf("%d", subtype);
				}
			}

			// Show international character sets
			SSHORT char_set_id = 0;
			if (!FLD.RDB$CHARACTER_SET_ID.NULL)
				char_set_id = FLD.RDB$CHARACTER_SET_ID;

			SSHORT collation = 0;
			if (!FLD.RDB$COLLATION_ID.NULL)
				collation = FLD.RDB$COLLATION_ID;

			if (((FLD.RDB$FIELD_TYPE == blr_text ||
				FLD.RDB$FIELD_TYPE == blr_varying) && FLD.RDB$FIELD_SUB_TYPE != fb_text_subtype_binary) ||
				FLD.RDB$FIELD_TYPE == blr_blob && FLD.RDB$FIELD_SUB_TYPE == isc_blob_text)
			{
				show_charsets(char_set_id, collation);
			}

			if (FLD.RDB$NULL_FLAG != 1) {
				isqlGlob.printf(" Nullable");
			}
			else {
				isqlGlob.printf(" Not Null");
			}
			isqlGlob.printf(NEWLINE);

			ISC_QUAD default_source;
			ISQL_get_default_source (NULL, FLD.RDB$FIELD_NAME, &default_source);
			if (default_source.gds_quad_high)
			{
				isqlGlob.printf("                                ");
				SHOW_print_metadata_text_blob (isqlGlob.Out, &default_source);
				isqlGlob.printf(NEWLINE);
			}

			if (!FLD.RDB$VALIDATION_SOURCE.NULL)
			{
				isqlGlob.printf("                                ");
				SHOW_print_metadata_text_blob (isqlGlob.Out, &FLD.RDB$VALIDATION_SOURCE);
				isqlGlob.printf(NEWLINE);
			}

		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR;
	}
	if (first)
		return (OBJECT_NOT_FOUND);
	return (SKIP);
}


static processing_state show_exceptions(const SCHAR* object)
{
/**************************************
 *
 *	s h o w _ e x c e p t i o n s
 *
 **************************************
 *
 * Functional description
 *	Show exceptions and their dependencies
 *	This version fetches all the exceptions, and only prints the
 *	one you asked for if you ask for one.  It could be optimized
 *	like other such functions.
 *
 **************************************/
	bool first = true;
	SCHAR type[20];

	//fb_utils::exact_name(object); It already comes trimmed.

	FOR EXC IN RDB$EXCEPTIONS
		SORTED BY EXC.RDB$EXCEPTION_NAME
	{
		fb_utils::exact_name(EXC.RDB$EXCEPTION_NAME);
		// List all objects if none specified, or just the named exception

		if (!*object || !strcmp (EXC.RDB$EXCEPTION_NAME, object))
		{
			first = false;

			isqlGlob.printf("%s", EXC.RDB$EXCEPTION_NAME);

			if (!EXC.RDB$MESSAGE.NULL && strlen(EXC.RDB$MESSAGE))
				isqlGlob.printf("; Msg: %s", EXC.RDB$MESSAGE);

			// Look up dependent objects --procedures and triggers
			bool first_dep = true;
			FOR DEP IN RDB$DEPENDENCIES WITH
				DEP.RDB$DEPENDED_ON_TYPE = obj_exception AND
				DEP.RDB$DEPENDED_ON_NAME EQ EXC.RDB$EXCEPTION_NAME
				SORTED BY DEP.RDB$DEPENDENT_TYPE, DEP.RDB$DEPENDENT_NAME
			{
				if (first_dep)
				{
					isqlGlob.printf("; Used by: ");
					first_dep = false;
				}
				else
					isqlGlob.printf(", ");

				fb_utils::exact_name(DEP.RDB$DEPENDENT_NAME);

				switch (DEP.RDB$DEPENDENT_TYPE)
				{
					case obj_trigger:
						strcpy (type, "Trigger");
						break;
					case obj_procedure:
						strcpy (type, "Stored procedure");
						break;
					default:
						strcpy (type, "Unknown");
						break;
				}

				isqlGlob.printf("%s (%s)", DEP.RDB$DEPENDENT_NAME, type);
			}
			END_FOR
			ON_ERROR
				ISQL_errmsg (fbStatus);
				return ps_ERR;
			END_ERROR;

			isqlGlob.printf(NEWLINE);
		}
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR;
	if (first)
		return (OBJECT_NOT_FOUND);
	return (SKIP);
}


static processing_state show_filters(const SCHAR* object)
{
/**************************************
 *
 *	s h o w _ f i l t e r s
 *
 **************************************
 *
 * Functional description
 *	Show blob filters in general or  for the named filters
 *
 **************************************/
	bool first = true;

	// Show all functions
	if (!*object)
	{
		FOR FIL IN RDB$FILTERS
		SORTED BY FIL.RDB$FUNCTION_NAME
		{
			first = false;
			fb_utils::exact_name(FIL.RDB$FUNCTION_NAME);
			isqlGlob.printf("%s%s", FIL.RDB$FUNCTION_NAME, NEWLINE);
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR;
		if (!first)
		{
			isqlGlob.printf(NEWLINE);
			return (SKIP);
		}

		return OBJECT_NOT_FOUND;
	}

	// We have a filter name, so expand on it
	FOR FIL IN RDB$FILTERS WITH
	   FIL.RDB$FUNCTION_NAME EQ object

	   first = false;

	   fb_utils::exact_name(FIL.RDB$FUNCTION_NAME);
	   fb_utils::exact_name(FIL.RDB$MODULE_NAME);
	   fb_utils::exact_name(FIL.RDB$ENTRYPOINT);

	   isqlGlob.printf("BLOB Filter: %s %s%sInput subtype: %d Output subtype: %d%s",
				FIL.RDB$FUNCTION_NAME, NEWLINE,
				TAB_AS_SPACES, FIL.RDB$INPUT_SUB_TYPE, FIL.RDB$OUTPUT_SUB_TYPE, NEWLINE);
	   isqlGlob.printf("%sFilter library is %s%s%sEntry point is %s%s%s",
				TAB_AS_SPACES, FIL.RDB$MODULE_NAME, NEWLINE,
				TAB_AS_SPACES, FIL.RDB$ENTRYPOINT, NEWLINE,
				NEWLINE);

	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR;

	if (first)
		return (OBJECT_NOT_FOUND);
	return (SKIP);
}


static processing_state show_functions(
	const char* funcname, const char* packname, bool quoted, bool system, const char* msg)
{
/**************************************
 *
 *	s h o w _ f u n c t i o n s
 *
 **************************************
 *
 * Functional description
 *	Show functions in general or for the named function
 *
 **************************************/

	int systemFlag = system ? 1 : 0;

	// If no function name was given, just list the functions
	if (!funcname || !strlen(funcname))
	{
		bool first = true;

		// This query gets the function name; the next query
		// gets all the dependencies if any

		FOR FUN IN RDB$FUNCTIONS
			WITH FUN.RDB$SYSTEM_FLAG EQ systemFlag
			SORTED BY FUN.RDB$PACKAGE_NAME, FUN.RDB$FUNCTION_NAME
		{
			if (first)
			{
				first = false;
				if (msg)
					isqlGlob.printf("%s%s", msg, NEWLINE);
			}

			MetaString package(FUN.RDB$PACKAGE_NAME);
			MetaString function(FUN.RDB$FUNCTION_NAME);

			isqlGlob.printf("%s%s%s", package.c_str(), package.hasData() ? "." : "", function.c_str());

			if (!(FUN.RDB$VALID_BLR.NULL || FUN.RDB$VALID_BLR))
				isqlGlob.printf("; Invalid");

			if (FUN.RDB$PACKAGE_NAME.NULL)
			{
				bool first_dep = true;
				FOR DEP IN RDB$DEPENDENCIES WITH
					FUN.RDB$FUNCTION_NAME EQ DEP.RDB$DEPENDENT_NAME
					REDUCED TO DEP.RDB$DEPENDED_ON_TYPE, DEP.RDB$DEPENDED_ON_NAME
					SORTED BY DEP.RDB$DEPENDED_ON_TYPE, DEP.RDB$DEPENDED_ON_NAME
				{
					fb_utils::exact_name(DEP.RDB$DEPENDED_ON_NAME);

					if (first_dep)
					{
						isqlGlob.printf("; Dependencies: ");
						first_dep = false;
					}
					else
						isqlGlob.printf(", ");

					isqlGlob.printf("%s (%s)", fb_utils::exact_name(DEP.RDB$DEPENDED_ON_NAME),
						Object_types[DEP.RDB$DEPENDED_ON_TYPE]);
				}
				END_FOR
				ON_ERROR
					ISQL_errmsg (fbStatus);
					return ps_ERR;
				END_ERROR;
			}

			isqlGlob.printf(NEWLINE);
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR;

		if (first)
			return OBJECT_NOT_FOUND;
		return (SKIP);
	}

	processing_state return_state = OBJECT_NOT_FOUND;

	const MetaString function(funcname);
	const MetaString package(packname);

	FOR FUN IN RDB$FUNCTIONS
		WITH FUN.RDB$FUNCTION_NAME EQ funcname
			AND FUN.RDB$PACKAGE_NAME EQUIV NULLIF(package.c_str(), '')

		if (!FUN.RDB$MODULE_NAME.NULL)
		{
			fb_assert(package.isEmpty());
			return_state = show_func_legacy(function);
		}
		else if (isqlGlob.major_ods >= ODS_VERSION12)
			return_state = show_func(package, function);

	END_FOR

	return return_state;
}


static processing_state show_func(const MetaString& package, const MetaString& function)
{
/**************************************
 *
 *	s h o w _ f u n c
 *
 **************************************
 *
 * Functional description
 *	Show function.
 *
 **************************************/
	fb_assert(isqlGlob.major_ods >= ODS_VERSION12);

	bool first = true;

	FOR FUN IN RDB$FUNCTIONS
		WITH FUN.RDB$FUNCTION_NAME EQ function.c_str()
			AND FUN.RDB$PACKAGE_NAME EQUIV NULLIF(package.c_str(), '')

		first = false;

		if (!FUN.RDB$DETERMINISTIC_FLAG.NULL && FUN.RDB$DETERMINISTIC_FLAG)
			isqlGlob.printf("Deterministic function%s", NEWLINE);

		if (!FUN.RDB$ENTRYPOINT.NULL)
		{
			fb_utils::exact_name(FUN.RDB$ENTRYPOINT);
			isqlGlob.printf("External name: %s%s", FUN.RDB$ENTRYPOINT, NEWLINE);
		}

		if (!FUN.RDB$SQL_SECURITY.NULL)
		{
			const char* ss = FUN.RDB$SQL_SECURITY ? "DEFINER" : "INVOKER";
			isqlGlob.printf("SQL SECURITY: %s%s", ss, NEWLINE);
		}

		if (!FUN.RDB$ENGINE_NAME.NULL)
		{
			fb_utils::exact_name(FUN.RDB$ENGINE_NAME);
			isqlGlob.printf("Engine: %s%s", FUN.RDB$ENGINE_NAME, NEWLINE);
		}

		if (!FUN.RDB$FUNCTION_SOURCE.NULL)
		{
			isqlGlob.printf("Function text:%s", NEWLINE);
			isqlGlob.printf("=============================================================================%s", NEWLINE);
			SHOW_print_metadata_text_blob(isqlGlob.Out, &FUN.RDB$FUNCTION_SOURCE);
			isqlGlob.printf("%s=============================================================================%s", NEWLINE, NEWLINE);
		}

		bool first_param = true;
		const SSHORT default_charset = ISQL_get_default_char_set_id();

		FOR ARG IN RDB$FUNCTION_ARGUMENTS CROSS
			FLD IN RDB$FIELDS WITH
			FUN.RDB$FUNCTION_NAME EQ ARG.RDB$FUNCTION_NAME AND
			ARG.RDB$PACKAGE_NAME EQUIV NULLIF(package.c_str(), '') AND
			ARG.RDB$FIELD_SOURCE EQ FLD.RDB$FIELD_NAME
			SORTED BY ARG.RDB$ARGUMENT_POSITION

			if (first_param)
			{
				isqlGlob.printf("Parameters:%s", NEWLINE);
				first_param = false;
			}
			fb_utils::exact_name(ARG.RDB$ARGUMENT_NAME);

			isqlGlob.printf("%-33s %s ", ARG.RDB$ARGUMENT_NAME,
				(ARG.RDB$ARGUMENT_POSITION == FUN.RDB$RETURN_ARGUMENT ? "OUTPUT" : "INPUT"));

			prm_mech_t mechanism = prm_mech_normal;
			bool prm_default_source_null = true;
			ISC_QUAD prm_default_source;

			if (!ARG.RDB$ARGUMENT_MECHANISM.NULL)
				mechanism = (prm_mech_t) ARG.RDB$ARGUMENT_MECHANISM;

			if (ARG.RDB$ARGUMENT_POSITION != FUN.RDB$RETURN_ARGUMENT)
			{
				prm_default_source_null = ARG.RDB$DEFAULT_SOURCE.NULL;
				prm_default_source = ARG.RDB$DEFAULT_SOURCE;
			}

			char relationName[BUFFER_LENGTH256] = "";
			char relationField[BUFFER_LENGTH256] = "";

			if (!ARG.RDB$RELATION_NAME.NULL)
			{
				strcpy(relationName, ARG.RDB$RELATION_NAME);
				fb_utils::exact_name(relationName);
			}

			if (!ARG.RDB$FIELD_NAME.NULL)
			{
				strcpy(relationField, ARG.RDB$FIELD_NAME);
				fb_utils::exact_name(relationField);
			}

			const bool basedOnColumn = relationName[0] && relationField[0];
			// Decide if this is a user-created domain
			if (!fb_utils::implicit_domain(FLD.RDB$FIELD_NAME) || FLD.RDB$SYSTEM_FLAG == 1 ||
				basedOnColumn)
			{
				isqlGlob.printf("(%s", (mechanism == prm_mech_type_of ? "TYPE OF " : ""));

				if (basedOnColumn)
					isqlGlob.printf("COLUMN %s.%s) ", relationName, relationField);
				else
				{
					fb_utils::exact_name(FLD.RDB$FIELD_NAME);
					isqlGlob.printf("%s) ", FLD.RDB$FIELD_NAME);
				}
			}

			if (!ISQL_printNumericType(FLD.RDB$FIELD_NAME, FLD.RDB$FIELD_TYPE, FLD.RDB$FIELD_SUB_TYPE,
					FLD.RDB$FIELD_PRECISION, FLD.RDB$FIELD_SCALE))
			{
				return ps_ERR;
			}

			// Use RDB$CHARACTER_LENGTH instead of RDB$FIELD_LENGTH
			//   FSG 19.Nov.2000
			if ((FLD.RDB$FIELD_TYPE == blr_text || FLD.RDB$FIELD_TYPE == blr_varying) &&
				!FLD.RDB$CHARACTER_LENGTH.NULL)
			{
				isqlGlob.printf("(%d)", FLD.RDB$CHARACTER_LENGTH);
			}

			// Show international character sets and collations

			if (((FLD.RDB$FIELD_TYPE == blr_text ||
				FLD.RDB$FIELD_TYPE == blr_varying) && FLD.RDB$FIELD_SUB_TYPE != fb_text_subtype_binary) ||
				FLD.RDB$FIELD_TYPE == blr_blob)
			{
				SSHORT charset = 0, collation = 0;

				if (!FLD.RDB$CHARACTER_SET_ID.NULL)
					charset = FLD.RDB$CHARACTER_SET_ID;

				bool prm_collation_null = ARG.RDB$COLLATION_ID.NULL;
				if (!prm_collation_null)
					collation = ARG.RDB$COLLATION_ID;

				if (prm_collation_null)
				{
					FOR RFL IN RDB$RELATION_FIELDS
						WITH RFL.RDB$RELATION_NAME = ARG.RDB$RELATION_NAME AND
							RFL.RDB$FIELD_NAME = ARG.RDB$FIELD_NAME

						prm_collation_null = RFL.RDB$COLLATION_ID.NULL;
						if (!prm_collation_null)
							collation = RFL.RDB$COLLATION_ID;
					END_FOR
				}

				if (prm_collation_null && !FLD.RDB$COLLATION_ID.NULL)
					collation = FLD.RDB$COLLATION_ID;

				show_charsets(charset, collation);
			}

			if (ARG.RDB$ARGUMENT_POSITION != FUN.RDB$RETURN_ARGUMENT) // input, try to show default and make Vlad happy.
			{
				if (!prm_default_source_null)
				{
					isqlGlob.printf(" ");
					SHOW_print_metadata_text_blob(isqlGlob.Out, &prm_default_source);
				}
				else if (fb_utils::implicit_domain(FLD.RDB$FIELD_NAME) && !FLD.RDB$DEFAULT_SOURCE.NULL)
				{
					isqlGlob.printf(" ");
					SHOW_print_metadata_text_blob(isqlGlob.Out, &FLD.RDB$DEFAULT_SOURCE);
				}
			}

			isqlGlob.printf(NEWLINE);

		END_FOR
		ON_ERROR
			ISQL_errmsg (fbStatus);
			return ps_ERR;
		END_ERROR;

	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR;
	if (first)
		return (OBJECT_NOT_FOUND);
	return (SKIP);
}


static processing_state show_func_legacy(const MetaString& function)
{
/**************************************
 *
 *	s h o w _ f u n c _ l e g a c y
 *
 **************************************
 *
 * Functional description
 *	Show legacy function.
 *
 **************************************/
	bool first = true;

	FOR FUN IN RDB$FUNCTIONS CROSS
		FNA IN RDB$FUNCTION_ARGUMENTS WITH
		FUN.RDB$FUNCTION_NAME EQ FNA.RDB$FUNCTION_NAME AND
		FNA.RDB$PACKAGE_NAME MISSING AND
		FUN.RDB$FUNCTION_NAME EQ function.c_str() AND
		FUN.RDB$PACKAGE_NAME MISSING AND
		FUN.RDB$MODULE_NAME NOT MISSING
		SORTED BY FNA.RDB$ARGUMENT_POSITION

		fb_utils::exact_name(FUN.RDB$FUNCTION_NAME);
		fb_utils::exact_name(FUN.RDB$MODULE_NAME);
		fb_utils::exact_name(FUN.RDB$ENTRYPOINT);
		if (first)
		{
			isqlGlob.printf("%sExternal function %s:%s", NEWLINE, FUN.RDB$FUNCTION_NAME, NEWLINE);
			isqlGlob.printf("Function library is %s%s", FUN.RDB$MODULE_NAME, NEWLINE);
			isqlGlob.printf("Entry point is %s%s", FUN.RDB$ENTRYPOINT, NEWLINE);
		}

		SSHORT ptype = (SSHORT) abs(FNA.RDB$MECHANISM);
		if (ptype > MAX_UDFPARAM_TYPES) {
			ptype = MAX_UDFPARAM_TYPES;
		}

		first = false;
		if (FUN.RDB$RETURN_ARGUMENT == FNA.RDB$ARGUMENT_POSITION)
		{
			isqlGlob.printf("Returns %s%s", UDF_param_types[ptype],
						(FNA.RDB$MECHANISM < 0 ? " FREE_IT " : " "));
		}
		else {
			isqlGlob.printf("Argument %d:%s ", FNA.RDB$ARGUMENT_POSITION, UDF_param_types[ptype]);
		}

		for (int i = 0; Column_types[i].type; i++)
		{
			if (FNA.RDB$FIELD_TYPE == Column_types[i].type)
			{
				bool precision_known = false;

				// Handle Integral subtypes NUMERIC and DECIMAL
				// We are ODS >= 10
				if ( (isqlGlob.major_ods >= ODS_VERSION10) &&
						((FNA.RDB$FIELD_TYPE == blr_short) ||
						(FNA.RDB$FIELD_TYPE == blr_long) ||
						(FNA.RDB$FIELD_TYPE == blr_int64) ||
						(FNA.RDB$FIELD_TYPE == blr_int128)) )
				{
					// We are Dialect >=3 since FIELD_PRECISION is non-NULL
					if (!FNA.RDB$FIELD_PRECISION.NULL &&
						FNA.RDB$FIELD_SUB_TYPE > 0 &&
						FNA.RDB$FIELD_SUB_TYPE <= MAX_INTSUBTYPES)
					{
						isqlGlob.printf("%s(%d, %d)",
									Integral_subtypes[FNA.RDB$FIELD_SUB_TYPE],
									FNA.RDB$FIELD_PRECISION,
									-FNA.RDB$FIELD_SCALE);
						precision_known = true;
					}
				}

				if (!precision_known)
				{
					// Take a stab at numerics and decimals
					if ((FNA.RDB$FIELD_TYPE == blr_short) && (FNA.RDB$FIELD_SCALE < 0))
						isqlGlob.printf("NUMERIC(4, %d)", -FNA.RDB$FIELD_SCALE);
					else if ((FNA.RDB$FIELD_TYPE == blr_long) && (FNA.RDB$FIELD_SCALE < 0))
						isqlGlob.printf("NUMERIC(9, %d)", -FNA.RDB$FIELD_SCALE);
					else if ((FNA.RDB$FIELD_TYPE == blr_double) && (FNA.RDB$FIELD_SCALE < 0))
						isqlGlob.printf("NUMERIC(15, %d)", -FNA.RDB$FIELD_SCALE);
					else
						isqlGlob.printf("%s", Column_types[i].type_name);
				}
				break;
			}

		}
		// Print length where appropriate
		if (FNA.RDB$FIELD_TYPE == blr_text || FNA.RDB$FIELD_TYPE == blr_varying ||
			FNA.RDB$FIELD_TYPE == blr_cstring)
		{
			FOR V4FNA IN RDB$FUNCTION_ARGUMENTS CROSS
				CHARSET IN RDB$CHARACTER_SETS OVER RDB$CHARACTER_SET_ID
				WITH V4FNA.RDB$FUNCTION_NAME EQ FNA.RDB$FUNCTION_NAME AND
				V4FNA.RDB$PACKAGE_NAME MISSING AND
				V4FNA.RDB$ARGUMENT_POSITION EQ FNA.RDB$ARGUMENT_POSITION

				fb_utils::exact_name(CHARSET.RDB$CHARACTER_SET_NAME);
				isqlGlob.printf("(%d) CHARACTER SET %s",
							(FNA.RDB$FIELD_LENGTH / MAX (1, CHARSET.RDB$BYTES_PER_CHARACTER)),
							CHARSET.RDB$CHARACTER_SET_NAME);

			END_FOR
			ON_ERROR
				ISQL_errmsg (fbStatus);
				return ps_ERR;
			END_ERROR;
		}

		isqlGlob.printf(NEWLINE);

	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR;
	if (first)
		return (OBJECT_NOT_FOUND);
	return (SKIP);
}


static processing_state show_generators(const SCHAR* object)
{
/**************************************
 *
 *	s h o w _ g e n e r a t o r s
 *
 **************************************
 *
 * Functional description
 *	Show generators including the current number they return
 *      We do this by selecting the GEN_ID of each one,
 *         incrementing by 0 to not change the current value.
 *
 **************************************/
	bool found = false;
	const char genIdStr[] = "SELECT GEN_ID(%s, 0) FROM RDB$DATABASE";
	TEXT query[sizeof(genIdStr) + QUOTED_NAME_SIZE], gen_name[QUOTED_NAME_SIZE];

	Firebird::RefPtr<Firebird::IMetadataBuilder>
		mb(Firebird::REF_NO_INCR, fbMaster->getMetadataBuilder(fbStatus, 1));
	if (ISQL_errmsg (fbStatus))
		return ps_ERR;

	// If the user has set his client dialect to 1, we take that to
	// mean that he wants to see just the lower 32 bits of the
	// generator, as in V5.  Otherwise, we show him the whole 64-bit value.
	const bool use64 = isqlGlob.SQL_dialect >= SQL_DIALECT_V6_TRANSITION;
	mb->setType(fbStatus, 0, use64 ? SQL_INT64 : SQL_LONG);
	if (ISQL_errmsg (fbStatus))
		return ps_ERR;

	Firebird::RefPtr<Firebird::IMessageMetadata>
		outMetadata(Firebird::REF_NO_INCR, mb->getMetadata(fbStatus));
	if (ISQL_errmsg (fbStatus))
		return ps_ERR;

	Firebird::AlignedBuffer<20> outBuffer;
	fb_assert(outMetadata->getMessageLength(fbStatus) <= outBuffer.size());
	unsigned off = outMetadata->getOffset(fbStatus, 0);
	if (ISQL_errmsg (fbStatus))
		return ps_ERR;

	// Show all generators or named generator
	FOR GEN IN RDB$GENERATORS
		SORTED BY GEN.RDB$GENERATOR_NAME

		fb_utils::exact_name(GEN.RDB$GENERATOR_NAME);

		if ((!*object && (GEN.RDB$SYSTEM_FLAG.NULL || GEN.RDB$SYSTEM_FLAG == 0)) ||
			!strcmp(GEN.RDB$GENERATOR_NAME, object))
		{
			// Get the current id for each generator

			if (isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION) {
				IUTILS_copy_SQL_id (GEN.RDB$GENERATOR_NAME, gen_name, DBL_QUOTE);
			}
			else {
				// If we are extracting in dialect 1, identifiers may cause failures.
				strcpy(gen_name, GEN.RDB$GENERATOR_NAME);
			}

			fb_utils::snprintf(query, sizeof(query), genIdStr, gen_name);

			DB->execute(fbStatus, fbTrans, 0, query, isqlGlob.SQL_dialect,
				NULL, NULL, outMetadata, outBuffer);
			if (ISQL_errmsg (fbStatus))
				continue;

			found = true;
			ISC_INT64 val = use64 ? *((ISC_INT64*) &outBuffer[off]) : *((SLONG*) &outBuffer[off]);

			isqlGlob.printf("Generator %s, current value: %" SQUADFORMAT,
					 GEN.RDB$GENERATOR_NAME, val);
			if (isqlGlob.major_ods >= ODS_VERSION12)
			{
				FOR G2 IN RDB$GENERATORS
					WITH G2.RDB$GENERATOR_NAME = GEN.RDB$GENERATOR_NAME

					ISC_INT64 initval = !G2.RDB$INITIAL_VALUE.NULL ? G2.RDB$INITIAL_VALUE : 0;
					isqlGlob.printf(", initial value: %" SQUADFORMAT ", increment: %" SLONGFORMAT,
						initval, G2.RDB$GENERATOR_INCREMENT);

				END_FOR
				ON_ERROR
					ISQL_errmsg(fbStatus);
					return ps_ERR;
				END_ERROR;
			}

			isqlGlob.prints(NEWLINE);
		}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR;
	if (!found)
		return (OBJECT_NOT_FOUND);
	return SKIP;
}


static void show_index(SCHAR* relation_name,
					   SCHAR* index_name,
					   const SSHORT unique_flag,
					   const SSHORT index_type,
					   const SSHORT inactive)
{
/**************************************
 *
 *	s h o w _ i n d e x
 *
 **************************************
 *
 * Functional description
 *	Show an index.
 *
 *	relation_name -- Name of table to investigate
 *
 **************************************/

	// Strip trailing blanks

	fb_utils::exact_name(relation_name);
	fb_utils::exact_name(index_name);

	isqlGlob.printf("%s%s%s INDEX ON %s", index_name,
			(unique_flag ? " UNIQUE" : ""),
			(index_type == 1 ? " DESCENDING" : ""), relation_name);

	// Get column names

	SCHAR collist[BUFFER_LENGTH512];

	if (ISQL_get_index_segments(collist, sizeof(collist), index_name, false))
	{
		isqlGlob.printf("(%s) %s%s", collist, (inactive ? "(inactive)" : ""), NEWLINE);
	}
}


static processing_state show_indices(const char* name)
{
/**************************************
 *
 *	s h o w _ i n d i c e s
 *
 **************************************
 *
 * Functional description
 *	shows indices for a given table name or index name or all tables
 *
 *	Use a static SQL query to get the info and print it.
 *
 *	relation_name -- Name of table to investigate
 *
 **************************************/
	bool first = true;

	// The names stored in the database are all upper case

	if (*name)
	{
		FOR IDX IN RDB$INDICES WITH
			IDX.RDB$RELATION_NAME EQ name OR
			IDX.RDB$INDEX_NAME EQ name
			SORTED BY IDX.RDB$INDEX_NAME

			if (IDX.RDB$INDEX_INACTIVE.NULL)
				IDX.RDB$INDEX_INACTIVE = 0;

			show_index(IDX.RDB$RELATION_NAME, IDX.RDB$INDEX_NAME,
					   IDX.RDB$UNIQUE_FLAG, IDX.RDB$INDEX_TYPE, IDX.RDB$INDEX_INACTIVE);

			if (!IDX.RDB$EXPRESSION_BLR.NULL)
			{
				isqlGlob.printf(" COMPUTED BY ");
				if (!IDX.RDB$EXPRESSION_SOURCE.NULL)
					SHOW_print_metadata_text_blob (isqlGlob.Out, &IDX.RDB$EXPRESSION_SOURCE);
				isqlGlob.printf(NEWLINE);
			}

			if (ENCODE_ODS(isqlGlob.major_ods, isqlGlob.minor_ods) >= ODS_13_1)
			{
				FOR IDX2 IN RDB$INDICES WITH
					IDX2.RDB$INDEX_NAME = IDX.RDB$INDEX_NAME
					AND IDX2.RDB$CONDITION_SOURCE NOT MISSING
				{
					isqlGlob.printf(" ");
					SHOW_print_metadata_text_blob(isqlGlob.Out, &IDX2.RDB$CONDITION_SOURCE);
					isqlGlob.printf(NEWLINE);
				}
				END_FOR
			}

			first = false;
		END_FOR
			ON_ERROR ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR;
		if (first)
			return (OBJECT_NOT_FOUND);
		return (SKIP);

	}
	else
	{
		FOR IDX IN RDB$INDICES CROSS
			REL IN RDB$RELATIONS OVER RDB$RELATION_NAME WITH
			REL.RDB$SYSTEM_FLAG NE 1 OR
			REL.RDB$SYSTEM_FLAG MISSING
			SORTED BY IDX.RDB$RELATION_NAME, IDX.RDB$INDEX_NAME

			first = false;

			show_index(IDX.RDB$RELATION_NAME, IDX.RDB$INDEX_NAME,
					   IDX.RDB$UNIQUE_FLAG, IDX.RDB$INDEX_TYPE, IDX.RDB$INDEX_INACTIVE);

			if (!IDX.RDB$EXPRESSION_BLR.NULL)
			{
				isqlGlob.printf(" COMPUTED BY ");
				if (!IDX.RDB$EXPRESSION_SOURCE.NULL)
					SHOW_print_metadata_text_blob (isqlGlob.Out, &IDX.RDB$EXPRESSION_SOURCE);
				isqlGlob.printf(NEWLINE);
			}

			if (ENCODE_ODS(isqlGlob.major_ods, isqlGlob.minor_ods) >= ODS_13_1)
			{
				FOR IDX2 IN RDB$INDICES WITH
					IDX2.RDB$INDEX_NAME = IDX.RDB$INDEX_NAME
					AND IDX2.RDB$CONDITION_SOURCE NOT MISSING
				{
					isqlGlob.printf(" ");
					SHOW_print_metadata_text_blob(isqlGlob.Out, &IDX2.RDB$CONDITION_SOURCE);
					isqlGlob.printf(NEWLINE);
				}
				END_FOR
			}

		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR;
		if (first)
			return (OBJECT_NOT_FOUND);
		return (SKIP);
	}
}


static processing_state show_packages(const SCHAR* package_name, bool sys, const SCHAR* msg)
{
/*************************************
*
*	s h o w _ p a c k a g e s
*
**************************************
*
* Functional description
*	Show all packages or the named package
************************************/
	if (isqlGlob.major_ods < ODS_VERSION12)
		return OBJECT_NOT_FOUND;

	bool first = true;

	if (!(package_name && *package_name))
	{
		//  List all package names in columns
		FOR PACK IN RDB$PACKAGES
			SORTED BY PACK.RDB$PACKAGE_NAME
		{
			bool system_flag = !PACK.RDB$SYSTEM_FLAG.NULL && PACK.RDB$SYSTEM_FLAG > 0;

			if (system_flag == sys)
			{
				if (first && msg)
					isqlGlob.printf("%s%s", msg, NEWLINE);
				first = false;

				isqlGlob.printf("%s%s", fb_utils::exact_name(PACK.RDB$PACKAGE_NAME), NEWLINE);
			}
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR;
		if (!first)
			isqlGlob.printf(NEWLINE);
	}
	else
	{
		// List named package

		FOR PACK IN RDB$PACKAGES WITH
			PACK.RDB$PACKAGE_NAME EQ package_name

			first = false;
			// Print the name of the package
			fb_utils::exact_name(PACK.RDB$PACKAGE_NAME);
			isqlGlob.printf("%-31s ", PACK.RDB$PACKAGE_NAME);

			isqlGlob.printf(NEWLINE);

			if (!PACK.RDB$SQL_SECURITY.NULL)
			{
				const char* ss = PACK.RDB$SQL_SECURITY ? "DEFINER" : "INVOKER";
				isqlGlob.printf("SQL SECURITY: %s%s", ss, NEWLINE);
			}

			if (!PACK.RDB$PACKAGE_HEADER_SOURCE.NULL)
			{
				isqlGlob.printf("%s%s", "Header source:", NEWLINE);
				SHOW_print_metadata_text_blob (isqlGlob.Out, &PACK.RDB$PACKAGE_HEADER_SOURCE);
				isqlGlob.printf(NEWLINE);
			}
			else
				isqlGlob.printf("Missing package header source.%s", NEWLINE);

			if (!PACK.RDB$PACKAGE_BODY_SOURCE.NULL)
			{
				isqlGlob.printf("%s%s%s:%s", NEWLINE, "Body source",
					(!PACK.RDB$VALID_BODY_FLAG.NULL && PACK.RDB$VALID_BODY_FLAG != 0 ?
						"" : " (invalid)"),
					NEWLINE);
				SHOW_print_metadata_text_blob (isqlGlob.Out, &PACK.RDB$PACKAGE_BODY_SOURCE);
				isqlGlob.printf(NEWLINE);
			}

		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR;
	}

	if (first)
		return (OBJECT_NOT_FOUND);

	return (SKIP);
}


static void printIdent(bool quote, char* ident, const char* format = NULL)
{
	fb_utils::exact_name(ident);
	char quotedIdent[BUFFER_LENGTH256];
	if (quote && isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
	{
		IUTILS_copy_SQL_id(ident, quotedIdent, DBL_QUOTE);
		ident = quotedIdent;
	}

	isqlGlob.printf(format ? format : "%s", ident);
}


static void printMap(bool extract, bool global, char* name, char* usng, char* plugin, char* db,
	char* fromType, char* from, short toType, char* to)
{
	if (extract)
	{
		isqlGlob.printf("CREATE ");
		if (global)
			isqlGlob.printf("OR ALTER GLOBAL ");
	}
	printIdent(extract, name, extract ? "MAPPING %s " : "%s ");

	isqlGlob.printf("USING ");
	switch (usng[0])
	{
	case 'P':
		if (!plugin)
			isqlGlob.printf("ANY PLUGIN ");
		else
			printIdent(extract, plugin, "PLUGIN %s ");
		break;
	case 'S':
		isqlGlob.printf("ANY PLUGIN SERVERWIDE ");
		break;
	case '*':
		isqlGlob.printf("* ");
		break;
	case 'M':
		isqlGlob.printf("MAPPING ");
		break;
	default:
		isqlGlob.printf("/*unknown = %c*/ ", usng[0]);
	}

	if (db)
		printIdent(extract, db, "IN %s ");

	fb_utils::exact_name(from);
	bool anyObj = strcmp(from, "*") == 0;
	isqlGlob.printf("FROM %s", anyObj ? "ANY " : "");
	printIdent(extract, fromType, "%s ");
	if (!anyObj)
		isqlGlob.printf("\'%s\' ", from);

	isqlGlob.printf("TO %s ", toType ? "ROLE" : "USER");
	if (to)
		printIdent(extract, to);
	isqlGlob.printf("%s%s", extract ? ";" : "", NEWLINE);
}


processing_state SHOW_maps(bool extract, const SCHAR* map_name)
{
/*************************************
*
*	s h o w _ m a p s
*
**************************************
*
* Functional description
*	Show all maps or maps to map_name
************************************/
	if (isqlGlob.major_ods < ODS_VERSION12)
		return OBJECT_NOT_FOUND;

	bool first = true;

	//  List all mappings
	FOR M IN RDB$AUTH_MAPPING WITH
		(M.RDB$SYSTEM_FLAG NE 1 OR M.RDB$SYSTEM_FLAG MISSING)
		SORTED BY M.RDB$MAP_NAME

		Firebird::NoCaseString nm = M.RDB$MAP_NAME;
		nm.trim();

		if ((!*map_name) || (nm == map_name))
		{
			if (first && extract)
				isqlGlob.printf("%s/* Mapping security objects for this database */%s", NEWLINE, NEWLINE);
			first = false;

			printMap(extract, false, M.RDB$MAP_NAME, M.RDB$MAP_USING,
				(M.RDB$MAP_PLUGIN.NULL ? NULL : M.RDB$MAP_PLUGIN),
				(M.RDB$MAP_DB.NULL ? NULL : M.RDB$MAP_DB),
				M.RDB$MAP_FROM_TYPE, M.RDB$MAP_FROM,
				M.RDB$MAP_TO_TYPE, (M.RDB$MAP_TO.NULL ? NULL : M.RDB$MAP_TO));
		}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR;

	bool firstGlobal = true;

	//  List global mappings
	FOR M IN SEC$GLOBAL_AUTH_MAPPING
		SORTED BY M.SEC$MAP_NAME

		Firebird::NoCaseString nm = M.SEC$MAP_NAME;
		nm.trim();

		if ((!*map_name) || (nm == map_name))
		{
			if (firstGlobal)
			{
				const char* sep = extract ? "/" : "**";
				isqlGlob.printf("%s%s* Global mapping *%s%s",
					(first && (!extract)) ? "" : NEWLINE, sep, sep, NEWLINE);
				firstGlobal = false;
			}

			first = false;

			printMap(extract, true, M.SEC$MAP_NAME, M.SEC$MAP_USING,
				(M.SEC$MAP_PLUGIN.NULL ? NULL : M.SEC$MAP_PLUGIN),
				(M.SEC$MAP_DB.NULL ? NULL : M.SEC$MAP_DB),
				M.SEC$MAP_FROM_TYPE, M.SEC$MAP_FROM,
				M.SEC$MAP_TO_TYPE, (M.SEC$MAP_TO.NULL ? NULL : M.SEC$MAP_TO));
		}
	END_FOR
	ON_ERROR
		if (!extract)
			ISQL_errmsg(fbStatus);		// report error but not return error on it
	END_ERROR;

	return first ? OBJECT_NOT_FOUND : SKIP;
}


static processing_state show_proc(const char* procname, const char* packname, bool quoted, bool sys, const char* msg)
{
/**************************************
 *
 *	s h o w _ p r o c
 *
 **************************************
 *
 * Functional description
 *	shows text of a stored procedure given a name.
 *	or lists procedures if no argument.
 *
 *	procname -- Name of procedure to investigate
 *
 **************************************/

	// If no procedure name was given, just list the procedures

	if (!procname || !strlen(procname))
	{
		// This query gets the procedure name; the next query
		// gets all the dependencies if any

		bool first_proc = true;

		FOR PRC IN RDB$PROCEDURES
			SORTED BY PRC.RDB$PACKAGE_NAME, PRC.RDB$PROCEDURE_NAME
		{
			bool system_flag = !PRC.RDB$SYSTEM_FLAG.NULL && PRC.RDB$SYSTEM_FLAG > 0;

			if (system_flag == sys)
			{
				if (first_proc)
				{
					if (msg)
						isqlGlob.printf("%s%s%s", NEWLINE, msg, NEWLINE);
					first_proc = false;
				}

				// Strip trailing blanks
				MetaString package(PRC.RDB$PACKAGE_NAME);
				MetaString procedure(PRC.RDB$PROCEDURE_NAME);

				isqlGlob.printf("%s%s%s", package.c_str(), package.hasData() ? "." : "", procedure.c_str());

				if (!(PRC.RDB$VALID_BLR.NULL || PRC.RDB$VALID_BLR))
					isqlGlob.printf("; Invalid");

				if (PRC.RDB$PACKAGE_NAME.NULL)
				{
					bool first_dep = true;
					FOR DEP IN RDB$DEPENDENCIES WITH
						PRC.RDB$PROCEDURE_NAME EQ DEP.RDB$DEPENDENT_NAME
						REDUCED TO DEP.RDB$DEPENDED_ON_TYPE, DEP.RDB$DEPENDED_ON_NAME
						SORTED BY DEP.RDB$DEPENDED_ON_TYPE, DEP.RDB$DEPENDED_ON_NAME
					{
						fb_utils::exact_name(DEP.RDB$DEPENDED_ON_NAME);

						if (first_dep)
						{
							isqlGlob.printf("; Dependencies: ");
							first_dep = false;
						}
						else
							isqlGlob.printf(", ");

						isqlGlob.printf("%s (%s)", fb_utils::exact_name(DEP.RDB$DEPENDED_ON_NAME),
							 Object_types[DEP.RDB$DEPENDED_ON_TYPE]);
					}
					END_FOR
					ON_ERROR
						ISQL_errmsg (fbStatus);
						return ps_ERR;
					END_ERROR;
				}

				isqlGlob.printf(NEWLINE);
			}
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR;

		if (first_proc)
			return OBJECT_NOT_FOUND;

		isqlGlob.printf(NEWLINE);
		return (SKIP);
	}

	// A procedure was named, so print all the info on that procedure

	bool first = true;

	const MetaString procedure(procname);
	const MetaString package(packname);

	FOR PRC IN RDB$PROCEDURES WITH
		PRC.RDB$PROCEDURE_NAME EQ procedure.c_str() AND
		PRC.RDB$PACKAGE_NAME EQUIV NULLIF(package.c_str(), '')

		first = false;

		if (!PRC.RDB$ENTRYPOINT.NULL)
		{
			fb_utils::exact_name(PRC.RDB$ENTRYPOINT);
			isqlGlob.printf("External name: %s%s", PRC.RDB$ENTRYPOINT, NEWLINE);
		}

		if (!PRC.RDB$SQL_SECURITY.NULL)
		{
			const char* ss = PRC.RDB$SQL_SECURITY ? "DEFINER" : "INVOKER";
			isqlGlob.printf("SQL SECURITY: %s%s", ss, NEWLINE);
		}

		if (!PRC.RDB$ENGINE_NAME.NULL)
		{
			fb_utils::exact_name(PRC.RDB$ENGINE_NAME);
			isqlGlob.printf("Engine: %s%s", PRC.RDB$ENGINE_NAME, NEWLINE);
		}

		if (!PRC.RDB$PROCEDURE_SOURCE.NULL)
		{
			isqlGlob.printf("Procedure text:%s", NEWLINE);
			isqlGlob.printf("=============================================================================%s", NEWLINE);
			SHOW_print_metadata_text_blob (isqlGlob.Out, &PRC.RDB$PROCEDURE_SOURCE);
			isqlGlob.printf("%s=============================================================================%s", NEWLINE, NEWLINE);
		}

		bool first_param = true;

		FOR PRM IN RDB$PROCEDURE_PARAMETERS CROSS
			FLD IN RDB$FIELDS WITH
			PRM.RDB$PROCEDURE_NAME EQ PRC.RDB$PROCEDURE_NAME AND
			PRM.RDB$PACKAGE_NAME EQUIV NULLIF(package.c_str(), '') AND
			PRM.RDB$FIELD_SOURCE EQ FLD.RDB$FIELD_NAME
			SORTED BY PRM.RDB$PARAMETER_TYPE, PRM.RDB$PARAMETER_NUMBER

			if (first_param)
			{
				isqlGlob.printf("Parameters:%s", NEWLINE);
				first_param = false;
			}
			fb_utils::exact_name(PRM.RDB$PARAMETER_NAME);

			isqlGlob.printf("%-33s %s ", PRM.RDB$PARAMETER_NAME,
					 (PRM.RDB$PARAMETER_TYPE ? "OUTPUT" : "INPUT"));

			prm_mech_t mechanism = prm_mech_normal;
			bool prm_default_source_null = true;
			ISC_QUAD prm_default_source;

			SSHORT collation = 0;
			bool prm_collation_null = true;

			if (!PRM.RDB$PARAMETER_MECHANISM.NULL)
				mechanism = (prm_mech_t) PRM.RDB$PARAMETER_MECHANISM;

			if (PRM.RDB$PARAMETER_TYPE == 0)
			{
				prm_default_source_null = PRM.RDB$DEFAULT_SOURCE.NULL;
				prm_default_source = PRM.RDB$DEFAULT_SOURCE;
			}

			prm_collation_null = PRM.RDB$COLLATION_ID.NULL;
			if (!prm_collation_null)
				collation = PRM.RDB$COLLATION_ID;

			char relationName[BUFFER_LENGTH256] = "";
			char relationField[BUFFER_LENGTH256] = "";

			if (!PRM.RDB$RELATION_NAME.NULL)
			{
				strcpy(relationName, PRM.RDB$RELATION_NAME);
				fb_utils::exact_name(relationName);
			}

			if (!PRM.RDB$FIELD_NAME.NULL)
			{
				strcpy(relationField, PRM.RDB$FIELD_NAME);
				fb_utils::exact_name(relationField);
			}

			if (prm_collation_null)
			{
				FOR RFL IN RDB$RELATION_FIELDS
					WITH RFL.RDB$RELATION_NAME = PRM.RDB$RELATION_NAME AND
						 RFL.RDB$FIELD_NAME = PRM.RDB$FIELD_NAME

					prm_collation_null = RFL.RDB$COLLATION_ID.NULL;
					if (!prm_collation_null)
						collation = RFL.RDB$COLLATION_ID;
				END_FOR
			}

			if (prm_collation_null && !FLD.RDB$COLLATION_ID.NULL)
				collation = FLD.RDB$COLLATION_ID;

			const bool basedOnColumn = relationName[0] && relationField[0];
			// Decide if this is a user-created domain
			if (!fb_utils::implicit_domain(FLD.RDB$FIELD_NAME) || FLD.RDB$SYSTEM_FLAG == 1 ||
				basedOnColumn)
			{
				isqlGlob.printf("(%s", (mechanism == prm_mech_type_of ? "TYPE OF " : ""));

				if (basedOnColumn)
					isqlGlob.printf("COLUMN %s.%s) ", relationName, relationField);
				else
				{
					fb_utils::exact_name(FLD.RDB$FIELD_NAME);
					isqlGlob.printf("%s) ", FLD.RDB$FIELD_NAME);
				}
			}

			if (!ISQL_printNumericType(FLD.RDB$FIELD_NAME, FLD.RDB$FIELD_TYPE, FLD.RDB$FIELD_SUB_TYPE,
					FLD.RDB$FIELD_PRECISION, FLD.RDB$FIELD_SCALE))
			{
				return ps_ERR;
			}

			// Use RDB$CHARACTER_LENGTH instead of RDB$FIELD_LENGTH
			//   FSG 19.Nov.2000
			if ((FLD.RDB$FIELD_TYPE == blr_text || FLD.RDB$FIELD_TYPE == blr_varying) &&
				!FLD.RDB$CHARACTER_LENGTH.NULL)
			{
				isqlGlob.printf("(%d)", FLD.RDB$CHARACTER_LENGTH);
			}

			// Show international character sets and collations

			if (((FLD.RDB$FIELD_TYPE == blr_text ||
				FLD.RDB$FIELD_TYPE == blr_varying) && FLD.RDB$FIELD_SUB_TYPE != fb_text_subtype_binary) ||
				FLD.RDB$FIELD_TYPE == blr_blob)
			{
				SSHORT charset = 0;
				if (!FLD.RDB$CHARACTER_SET_ID.NULL)
					charset = FLD.RDB$CHARACTER_SET_ID;

				show_charsets(charset, collation);
			}

			if (PRM.RDB$PARAMETER_TYPE == 0) // input, try to show default and make Vlad happy.
			{
				if (!prm_default_source_null)
				{
					isqlGlob.printf(" ");
					SHOW_print_metadata_text_blob(isqlGlob.Out, &prm_default_source);
				}
				else if (fb_utils::implicit_domain(FLD.RDB$FIELD_NAME) && !FLD.RDB$DEFAULT_SOURCE.NULL)
				{
					isqlGlob.printf(" ");
					SHOW_print_metadata_text_blob(isqlGlob.Out, &FLD.RDB$DEFAULT_SOURCE);
				}
			}

			isqlGlob.printf(NEWLINE);
		END_FOR
		ON_ERROR
			ISQL_errmsg (fbStatus);
			return ps_ERR;
		END_ERROR;
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR;
	if (first)
		return (OBJECT_NOT_FOUND);
	return (SKIP);
}


static processing_state show_publications(const SCHAR* pub_name, bool sys, const SCHAR* msg)
{
/**************************************
 *
 *	s h o w _ p u b l i c a t i o n s
 *
 **************************************
 *
 * Functional description
 *	Show publications.
 *
 **************************************/
	if (isqlGlob.major_ods < ODS_VERSION13)
		return OBJECT_NOT_FOUND;

	bool first = true;

	if (pub_name && *pub_name)
	{
		// List named publication

		FOR PUB IN RDB$PUBLICATIONS WITH
			PUB.RDB$PUBLICATION_NAME EQ pub_name

			first = false;

			fb_utils::exact_name(PUB.RDB$PUBLICATION_NAME);
			isqlGlob.printf("%s: ", PUB.RDB$PUBLICATION_NAME);

			const bool active_flag = (!PUB.RDB$ACTIVE_FLAG.NULL && PUB.RDB$ACTIVE_FLAG > 0);
			isqlGlob.printf("%s", active_flag ? "Enabled" : "Disabled");

			if (!PUB.RDB$AUTO_ENABLE.NULL && PUB.RDB$AUTO_ENABLE > 0)
				isqlGlob.printf(", Auto-enable");

			isqlGlob.printf(NEWLINE);

		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR;
	}
	else
	{
		//  List all publications

		FOR PUB IN RDB$PUBLICATIONS
			SORTED BY PUB.RDB$PUBLICATION_NAME

			const bool system_flag = (!PUB.RDB$SYSTEM_FLAG.NULL && PUB.RDB$SYSTEM_FLAG > 0);

			if (system_flag == sys)
			{
				if (first && msg)
					isqlGlob.printf("%s%s", msg, NEWLINE);

				first = false;

				isqlGlob.printf("%s%s", fb_utils::exact_name(PUB.RDB$PUBLICATION_NAME), NEWLINE);
			}

		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR;

		if (!first)
			isqlGlob.printf(NEWLINE);
	}

	if (first)
		return (OBJECT_NOT_FOUND);

	return (SKIP);
}


static void show_pub_table(const SCHAR* table_name)
{
/**************************************
 *
 *	s h o w _ p u b _ t a b l e
 *
 **************************************
 *
 * Functional description
 *	Show publication status for the given table.
 *
 **************************************/
	if (isqlGlob.major_ods < ODS_VERSION13)
		return;

	bool first = true;

	if (table_name && *table_name)
	{
		FOR PTAB IN RDB$PUBLICATION_TABLES CROSS
			PUB IN RDB$PUBLICATIONS OVER RDB$PUBLICATION_NAME WITH
			PTAB.RDB$TABLE_NAME EQ table_name
			SORTED BY DESCENDING PUB.RDB$SYSTEM_FLAG, PUB.RDB$PUBLICATION_NAME

			const auto pub_name = fb_utils::exact_name(PUB.RDB$PUBLICATION_NAME);

			if (first)
			{
				TEXT msg[MSG_LENGTH];
				IUTILS_msg_get(MSG_PUBLICATIONS, msg);
				isqlGlob.printf("%s %s", msg, pub_name);
			}
			else
				isqlGlob.printf(", %s", pub_name);

			const bool active_flag = (!PUB.RDB$ACTIVE_FLAG.NULL && PUB.RDB$ACTIVE_FLAG > 0);
			isqlGlob.printf(" (%s)", active_flag ? "Enabled" : "Disabled");

			first = false;

		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return;
		END_ERROR;
	}

	if (!first)
		isqlGlob.printf(NEWLINE);
}


bool SHOW_system_privileges(const char* role, const char* prefix, bool lf)
{
	bool first = true;

	FOR X IN RDB$ROLES WITH
		X.RDB$ROLE_NAME EQ role
	{
		if (!X.RDB$SYSTEM_PRIVILEGES.NULL)
		{
			for (unsigned byte = 0; byte < sizeof(X.RDB$SYSTEM_PRIVILEGES); ++byte)
			{
				char b = X.RDB$SYSTEM_PRIVILEGES[byte];
				for (int bit = 0; bit < 8; ++bit)
				{
					if (b & (1 << bit))
					{
						FOR T IN RDB$TYPES
							WITH T.RDB$FIELD_NAME EQ 'RDB$SYSTEM_PRIVILEGES' AND
								 T.RDB$TYPE EQ (byte * 8 + bit)
						{
							if (first)
							{
								if (lf)
									isqlGlob.printf("%s", NEWLINE);
								isqlGlob.printf("%s", prefix);
							}
							else
								isqlGlob.printf(",");

							first = false;
							isqlGlob.printf(" %s", fb_utils::exact_name(T.RDB$TYPE_NAME));
						}
						END_FOR
					}
				}
			}
		}
	}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return false;
	END_ERROR;

	return !first;
}


static processing_state show_role(const SCHAR* object, bool system, const char* msg)
{
	if (isqlGlob.major_ods < ODS_VERSION9)
		return OBJECT_NOT_FOUND;

	if (object == NULL)
	{
		// show role with no parameters, show all roles
		// **************************************
		// * Print the names of all roles from
		// * RDB$ROLES.  We use a dynamic query
		// * If there is any roles, then returns SKIP.
		// *	Otherwise returns OBJECT_NOT_FOUND.
		// **************************************/
		bool first = true;

		FOR X IN RDB$ROLES WITH
			X.RDB$ROLE_NAME NOT MISSING
			SORTED BY X.RDB$ROLE_NAME
		{
			bool system_flag = !X.RDB$SYSTEM_FLAG.NULL && X.RDB$SYSTEM_FLAG > 0;

			if (system_flag == system)
			{
				if (first && msg)
					isqlGlob.printf("%s%s", msg, NEWLINE);
				first = false;

				isqlGlob.printf("%s%s", fb_utils::exact_name(X.RDB$ROLE_NAME), NEWLINE);

				/***
				if (SHOW_system_privileges(X.RDB$ROLE_NAME, "System privileges:", !odd))
				{
					isqlGlob.printf("%s", NEWLINE);
					odd = true;
				}
				***/
			}
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR;

		if (!first)
		{
			isqlGlob.printf(NEWLINE);
			return SKIP;
		}

		return OBJECT_NOT_FOUND;
	}

	// show role with role supplied, display users and other roles granted this role
	SCHAR role_name[BUFFER_LENGTH256];
	bool first = true;

	FOR FIRST 1 R IN RDB$ROLES WITH R.RDB$ROLE_NAME EQ object

		FOR PRV IN RDB$USER_PRIVILEGES WITH
			PRV.RDB$OBJECT_TYPE   EQ obj_sql_role AND
			(PRV.RDB$USER_TYPE    EQ obj_user      OR
			 PRV.RDB$USER_TYPE     EQ obj_sql_role) AND
			PRV.RDB$RELATION_NAME EQ object       AND
			PRV.RDB$PRIVILEGE     EQ 'M'
			SORTED BY  PRV.RDB$USER

			if (first)
			{
				first = false;
				fb_utils::exact_name(PRV.RDB$RELATION_NAME);
				strcpy(role_name, PRV.RDB$RELATION_NAME);
				if (isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
					IUTILS_copy_SQL_id(role_name, SQL_identifier, DBL_QUOTE);
				else
					strcpy(SQL_identifier, role_name);

				isqlGlob.printf("Role %s is granted to:%s", SQL_identifier, NEWLINE);
			}

			fb_utils::exact_name(PRV.RDB$USER);
			isqlGlob.printf("%s%s", PRV.RDB$USER, NEWLINE);

		END_FOR
		ON_ERROR
			ISQL_errmsg (fbStatus);
			return ps_ERR;
		END_ERROR

		if (first)
		{
		    first = false;
			fb_utils::exact_name(R.RDB$ROLE_NAME);
			strcpy(role_name, R.RDB$ROLE_NAME);
			if (isqlGlob.db_SQL_dialect > SQL_DIALECT_V6_TRANSITION)
				IUTILS_copy_SQL_id(role_name, SQL_identifier, DBL_QUOTE);
			else
				strcpy(SQL_identifier, role_name);

		    isqlGlob.printf("Role %s isn't granted to anyone.%s", SQL_identifier, NEWLINE);
		}

	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	if (first)
		return (OBJECT_NOT_FOUND);
	else if (SHOW_system_privileges(object, "System privileges:", false))
		isqlGlob.printf("%s", NEWLINE);

	return (SKIP);
}


// ***********************
// s h o w _ s e c c l a s
// ***********************
// Show low-level, GDML security for an object. It may be table/view or procedure.
// Using SHOW SECCLASS <name> DET[AIL] will print the contents of the sec blob.
// Using SHOW SECCLASS * DET[AIL] will print the db-wide sec class in rdb$database.
static processing_state show_secclass(const std::optional<MetaString>& object, bool detail)
{
	IsqlVar var;
	memset(&var, 0, sizeof(var));
	var.subType = isc_blob_acl;

	int count = 0;

	if (!object)
	{
		FOR D IN RDB$DATABASE
		CROSS SC IN RDB$SECURITY_CLASSES
		OVER RDB$SECURITY_CLASS
			++count;
			isqlGlob.printf("Database-wide's sec class %s%s",
				fb_utils::exact_name(SC.RDB$SECURITY_CLASS), NEWLINE);
			if (detail)
			{
				var.value.setPtr = &SC.RDB$ACL;
				ISQL_print_item_blob(isqlGlob.Out, &var, fbTrans, isc_blob_acl);
			}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR

		return count ? SKIP : OBJECT_NOT_FOUND;
	}

	FOR REL IN RDB$RELATIONS
	CROSS SC IN RDB$SECURITY_CLASSES
	OVER RDB$SECURITY_CLASS
	WITH REL.RDB$RELATION_NAME EQ object->c_str()
		++count;
		isqlGlob.printf("%s's main sec class %s%s",
			REL.RDB$VIEW_BLR.NULL ? "Table" : "View",
			fb_utils::exact_name(SC.RDB$SECURITY_CLASS), NEWLINE);
		if (detail)
		{
			var.value.asChar = reinterpret_cast<char*>(&SC.RDB$ACL);
			ISQL_print_item_blob(isqlGlob.Out, &var, fbTrans, isc_blob_acl);
		}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	FOR REL2 IN RDB$RELATIONS
	CROSS SC IN RDB$SECURITY_CLASSES
	WITH REL2.RDB$RELATION_NAME EQ object->c_str()
	AND REL2.RDB$DEFAULT_CLASS EQ SC.RDB$SECURITY_CLASS
		++count;
		isqlGlob.printf("%s's default sec class %s%s",
			REL2.RDB$VIEW_BLR.NULL ? "Table" : "View",
			fb_utils::exact_name(SC.RDB$SECURITY_CLASS), NEWLINE);
		if (detail)
		{
			var.value.asChar = reinterpret_cast<char*>(&SC.RDB$ACL);
			ISQL_print_item_blob(isqlGlob.Out, &var, fbTrans, isc_blob_acl);
		}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	FOR RF IN RDB$RELATION_FIELDS
	CROSS SC IN RDB$SECURITY_CLASSES
	OVER RDB$SECURITY_CLASS
	WITH RF.RDB$RELATION_NAME EQ object->c_str()
	SORTED BY RF.RDB$FIELD_POSITION
		++count;
		isqlGlob.printf("   Field %s - sec class %s%s", fb_utils::exact_name(RF.RDB$FIELD_NAME),
			SC.RDB$SECURITY_CLASS, NEWLINE);
		if (detail)
		{
			var.value.asChar = reinterpret_cast<char*>(&SC.RDB$ACL);
			ISQL_print_item_blob(isqlGlob.Out, &var, fbTrans, isc_blob_acl);
		}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	FOR PR IN RDB$PROCEDURES
	CROSS SC IN RDB$SECURITY_CLASSES
	OVER RDB$SECURITY_CLASS
	WITH PR.RDB$PROCEDURE_NAME EQ object->c_str() AND
		 PR.RDB$PACKAGE_NAME MISSING
		++count;
		isqlGlob.printf("Procedure's sec class %s%s",
			fb_utils::exact_name(SC.RDB$SECURITY_CLASS), NEWLINE);
		if (detail)
		{
			var.value.asChar = reinterpret_cast<char*>(&SC.RDB$ACL);
			ISQL_print_item_blob(isqlGlob.Out, &var, fbTrans, isc_blob_acl);
		}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	if (isqlGlob.major_ods >= ODS_VERSION12)
	{
		FOR FUN IN RDB$FUNCTIONS
		CROSS SC IN RDB$SECURITY_CLASSES
		OVER RDB$SECURITY_CLASS
		WITH FUN.RDB$FUNCTION_NAME EQ object->c_str() AND
			 FUN.RDB$PACKAGE_NAME MISSING
			++count;
			isqlGlob.printf("Function's sec class %s%s",
				fb_utils::exact_name(SC.RDB$SECURITY_CLASS), NEWLINE);
			if (detail)
			{
				var.value.asChar = reinterpret_cast<char*>(&SC.RDB$ACL);
				ISQL_print_item_blob(isqlGlob.Out, &var, fbTrans, isc_blob_acl);
			}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR

		FOR PKG IN RDB$PACKAGES
		CROSS SC IN RDB$SECURITY_CLASSES
		OVER RDB$SECURITY_CLASS
		WITH PKG.RDB$PACKAGE_NAME EQ object->c_str()
			++count;
			isqlGlob.printf("Package's sec class %s%s",
				fb_utils::exact_name(SC.RDB$SECURITY_CLASS), NEWLINE);
			if (detail)
			{
				var.value.asChar = reinterpret_cast<char*>(&SC.RDB$ACL);
				ISQL_print_item_blob(isqlGlob.Out, &var, fbTrans, isc_blob_acl);
			}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR

		FOR GEN IN RDB$GENERATORS
		CROSS SC IN RDB$SECURITY_CLASSES
		OVER RDB$SECURITY_CLASS
		WITH GEN.RDB$GENERATOR_NAME EQ object->c_str()
			++count;
			isqlGlob.printf("Sequence's sec class %s%s",
				fb_utils::exact_name(SC.RDB$SECURITY_CLASS), NEWLINE);
			if (detail)
			{
				var.value.asChar = reinterpret_cast<char*>(&SC.RDB$ACL);
				ISQL_print_item_blob(isqlGlob.Out, &var, fbTrans, isc_blob_acl);
			}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR

		FOR XCP IN RDB$EXCEPTIONS
		CROSS SC IN RDB$SECURITY_CLASSES
		OVER RDB$SECURITY_CLASS
		WITH XCP.RDB$EXCEPTION_NAME EQ object->c_str()
			++count;
			isqlGlob.printf("Exception's sec class %s%s",
				fb_utils::exact_name(SC.RDB$SECURITY_CLASS), NEWLINE);
			if (detail)
			{
				var.value.asChar = reinterpret_cast<char*>(&SC.RDB$ACL);
				ISQL_print_item_blob(isqlGlob.Out, &var, fbTrans, isc_blob_acl);
			}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR
	}

	return count ? SKIP : OBJECT_NOT_FOUND;
}


static processing_state show_table(const SCHAR* relation_name, bool isView)
{
/**************************************
 *
 *	s h o w _ t a b l e
 *
 **************************************
 *
 * Functional description
 *	shows columns, types, info for a given table name
 *	and text of views.
 *	Use a SQL query to get the info and print it.
 *	This also shows integrity constraints and triggers
 *
 *	relation_name -- Name of table to investigate
 *
 **************************************/
	bool first = true;

	// Query to obtain relation information
	// REL.RDB$VIEW_BLR NOT MISSING

	FOR REL IN RDB$RELATIONS
		WITH REL.RDB$RELATION_NAME EQ relation_name
		if (first)
		{
			if (!REL.RDB$SQL_SECURITY.NULL)
			{
				const char* ss = REL.RDB$SQL_SECURITY ? "DEFINER" : "INVOKER";
				isqlGlob.printf("SQL SECURITY: %s%s", ss, NEWLINE);
			}

			if (!REL.RDB$EXTERNAL_FILE.NULL)
				isqlGlob.printf("External file: %s%s", REL.RDB$EXTERNAL_FILE, NEWLINE);
		}
		first = false;
		if ((isView && REL.RDB$VIEW_BLR.NULL) || (!isView && !REL.RDB$VIEW_BLR.NULL))
			first = true;
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR;

	if (first)
		return (OBJECT_NOT_FOUND);

	/*
	FOR RFR IN RDB$RELATION_FIELDS CROSS
		REL IN RDB$RELATIONS CROSS
		FLD IN RDB$FIELDS WITH
		RFR.RDB$FIELD_SOURCE EQ FLD.RDB$FIELD_NAME AND
		RFR.RDB$RELATION_NAME EQ relation_name AND
		REL.RDB$RELATION_NAME EQ RFR.RDB$RELATION_NAME
		SORTED BY RFR.RDB$FIELD_POSITION, RFR.RDB$FIELD_NAME
	*/

	FOR RFR IN RDB$RELATION_FIELDS CROSS
		FLD IN RDB$FIELDS WITH
		RFR.RDB$FIELD_SOURCE EQ FLD.RDB$FIELD_NAME AND
		RFR.RDB$RELATION_NAME EQ relation_name
		SORTED BY RFR.RDB$FIELD_POSITION, RFR.RDB$FIELD_NAME

		// Get length of colname to align columns for printing

		fb_utils::exact_name(RFR.RDB$FIELD_NAME);

		// Print the column name in first column

		isqlGlob.printf("%-31s ", RFR.RDB$FIELD_NAME);

		// Decide if this is a user-created domain
		if (!(fb_utils::implicit_domain(FLD.RDB$FIELD_NAME) && FLD.RDB$SYSTEM_FLAG != 1))
		{
			fb_utils::exact_name(FLD.RDB$FIELD_NAME);
			isqlGlob.printf("(%s) ", FLD.RDB$FIELD_NAME);
		}

		// Detect the existence of arrays

		if (!FLD.RDB$DIMENSIONS.NULL)
		{
			isqlGlob.printf("ARRAY OF ");
			ISQL_array_dimensions (FLD.RDB$FIELD_NAME);
			isqlGlob.printf("%s                                ", NEWLINE);
		}

		// If a computed field, show the source and exit
		// Note that view columns which are computed are dealt with later.
		if (!FLD.RDB$COMPUTED_BLR.NULL && !isView)
		{
			isqlGlob.printf("Computed by: ");
			if (!FLD.RDB$COMPUTED_SOURCE.NULL)
				SHOW_print_metadata_text_blob (isqlGlob.Out, &FLD.RDB$COMPUTED_SOURCE);
			isqlGlob.printf(NEWLINE);
			continue;
		}

		if (!ISQL_printNumericType(FLD.RDB$FIELD_NAME, FLD.RDB$FIELD_TYPE, FLD.RDB$FIELD_SUB_TYPE,
				FLD.RDB$FIELD_PRECISION, FLD.RDB$FIELD_SCALE))
		{
			return ps_ERR;
		}

		SSHORT char_set_id = 0;
		if (!FLD.RDB$CHARACTER_SET_ID.NULL)
			char_set_id = FLD.RDB$CHARACTER_SET_ID;

		SSHORT collation = 0;
		if (!RFR.RDB$COLLATION_ID.NULL)
			collation = RFR.RDB$COLLATION_ID;
		else if (!FLD.RDB$COLLATION_ID.NULL)
			collation = FLD.RDB$COLLATION_ID;

		if ((FLD.RDB$FIELD_TYPE == blr_text) || (FLD.RDB$FIELD_TYPE == blr_varying)) {
			isqlGlob.printf("(%d)", ISQL_get_field_length(FLD.RDB$FIELD_NAME));

			if (FLD.RDB$FIELD_SUB_TYPE != fb_text_subtype_binary)
			{
				// Show international character sets and collations
				show_charsets(char_set_id, collation);
			}
		}

		if (FLD.RDB$FIELD_TYPE == blr_blob)
		{
			isqlGlob.printf(" segment %u, subtype ", (USHORT) FLD.RDB$SEGMENT_LENGTH);
			const int subtype  = FLD.RDB$FIELD_SUB_TYPE;
			if (subtype >= 0 && subtype <= MAX_BLOBSUBTYPES)
			{
				isqlGlob.prints(Sub_types[subtype]);
			}
			else
			{
				isqlGlob.printf("%d", subtype);
			}

			if (subtype == isc_blob_text)
			{
				// Show international character sets and collations
				show_charsets(char_set_id, collation);
			}
		}

		if (!FLD.RDB$COMPUTED_BLR.NULL)
		{
			// A view expression. Other computed fields will not reach this point.
			isqlGlob.printf(" Expression%s", NEWLINE);
			continue;
		}

		// The null flag is either 1 or null (for nullable)

		if (RFR.RDB$NULL_FLAG == 1 || FLD.RDB$NULL_FLAG == 1 ||
			(!RFR.RDB$BASE_FIELD.NULL && !ISQL_get_null_flag (relation_name, RFR.RDB$FIELD_NAME)))
		{
			isqlGlob.printf(" Not Null ");
		}
		else
		{
			isqlGlob.printf(" Nullable ");
		}

		if (!RFR.RDB$GENERATOR_NAME.NULL)
		{
			isqlGlob.printf("Identity (%s)",
				(RFR.RDB$IDENTITY_TYPE == IDENT_TYPE_BY_DEFAULT ? "by default" :
				 RFR.RDB$IDENTITY_TYPE == IDENT_TYPE_ALWAYS ? "always" : ""));
		}

		// Handle defaults for columns

		if (!RFR.RDB$DEFAULT_SOURCE.NULL)
			SHOW_print_metadata_text_blob (isqlGlob.Out, &RFR.RDB$DEFAULT_SOURCE);
		else if (!FLD.RDB$DEFAULT_SOURCE.NULL)
			SHOW_print_metadata_text_blob (isqlGlob.Out, &FLD.RDB$DEFAULT_SOURCE);
		isqlGlob.printf(NEWLINE);

		// Validation clause for domains
		if (!FLD.RDB$VALIDATION_SOURCE.NULL)
		{
			isqlGlob.printf("                                ");
			SHOW_print_metadata_text_blob (isqlGlob.Out, &FLD.RDB$VALIDATION_SOURCE);
			isqlGlob.printf(NEWLINE);
		}

	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR;

	// If this is a view and there were columns, print the view text

	if (!first)
	{
		FOR REL IN RDB$RELATIONS WITH
			REL.RDB$RELATION_NAME EQ relation_name AND
			REL.RDB$VIEW_BLR NOT MISSING

			isqlGlob.printf("View Source:%s==== ======%s", NEWLINE, NEWLINE);
			if (!REL.RDB$VIEW_SOURCE.NULL)
				SHOW_print_metadata_text_blob (isqlGlob.Out, &REL.RDB$VIEW_SOURCE);
			isqlGlob.printf(NEWLINE);
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR;
	}

	// Handle any referential or primary constraint on this table

	SCHAR collist[BUFFER_LENGTH512];

	// Static queries for obtaining referential constraints

	FOR RELC1 IN RDB$RELATION_CONSTRAINTS WITH
		RELC1.RDB$RELATION_NAME EQ relation_name
		SORTED BY RELC1.RDB$CONSTRAINT_TYPE, RELC1.RDB$CONSTRAINT_NAME

		fb_utils::exact_name(RELC1.RDB$CONSTRAINT_NAME);
		fb_utils::exact_name(RELC1.RDB$INDEX_NAME);
		ISQL_get_index_segments (collist, sizeof(collist), RELC1.RDB$INDEX_NAME, false);
		bool isPK = false;
		bool isUK = false;

		if (!strncmp (RELC1.RDB$CONSTRAINT_TYPE, "PRIMARY", 7))
		{
			isPK = true;
			isqlGlob.printf("CONSTRAINT %s:%s", RELC1.RDB$CONSTRAINT_NAME, NEWLINE);
			isqlGlob.printf("  Primary key (%s)", collist);
		}
		else if (!strncmp (RELC1.RDB$CONSTRAINT_TYPE, "UNIQUE", 6))
		{
			isUK = true;
			isqlGlob.printf("CONSTRAINT %s:%s", RELC1.RDB$CONSTRAINT_NAME, NEWLINE);
			isqlGlob.printf("  Unique key (%s)", collist);
		}
		else if (!strncmp (RELC1.RDB$CONSTRAINT_TYPE, "FOREIGN", 7))
		{
			isqlGlob.printf("CONSTRAINT %s:%s", RELC1.RDB$CONSTRAINT_NAME, NEWLINE);
			isqlGlob.printf("  Foreign key (%s)", collist);

			FOR RELC2 IN RDB$RELATION_CONSTRAINTS CROSS
				REFC IN RDB$REF_CONSTRAINTS WITH
				RELC2.RDB$CONSTRAINT_NAME EQ REFC.RDB$CONST_NAME_UQ AND
				REFC.RDB$CONSTRAINT_NAME EQ RELC1.RDB$CONSTRAINT_NAME

				ISQL_get_index_segments (collist, sizeof(collist), RELC2.RDB$INDEX_NAME, false);
				fb_utils::exact_name(RELC2.RDB$RELATION_NAME);

				isqlGlob.printf("    References %s (%s)", RELC2.RDB$RELATION_NAME, collist);

				if (!REFC.RDB$UPDATE_RULE.NULL)
				{
					IUTILS_truncate_term (REFC.RDB$UPDATE_RULE, static_cast<USHORT>(strlen(REFC.RDB$UPDATE_RULE)));
					ISQL_ri_action_print (REFC.RDB$UPDATE_RULE, " On Update", false);
				}

				if (!REFC.RDB$DELETE_RULE.NULL)
				{
					IUTILS_truncate_term (REFC.RDB$DELETE_RULE, static_cast<USHORT>(strlen(REFC.RDB$DELETE_RULE)));
					ISQL_ri_action_print (REFC.RDB$DELETE_RULE, " On Delete", false);
				}

				isqlGlob.printf(NEWLINE);

			END_FOR
			ON_ERROR
				ISQL_errmsg (fbStatus);
				return ps_ERR;
			END_ERROR;
		}

		if (isPK || isUK) // Special handling for PRIMARY KEY and UNIQUE constraints.
		{
			FOR IDX IN RDB$INDICES
			WITH IDX.RDB$INDEX_NAME = RELC1.RDB$INDEX_NAME
				// Yes, the same RDB$... naming convention is used for both domains and indices.
				const bool explicit_index =
					((isPK && !fb_utils::implicit_pk(IDX.RDB$INDEX_NAME)) ||
					(isUK && !fb_utils::implicit_domain(RELC1.RDB$INDEX_NAME))) &&
				    strcmp(RELC1.RDB$CONSTRAINT_NAME, RELC1.RDB$INDEX_NAME);
				const bool descending_index = !IDX.RDB$INDEX_TYPE.NULL && IDX.RDB$INDEX_TYPE == 1;
				if (explicit_index || descending_index)
				{
					isqlGlob.printf(" uses explicit %s index",
									descending_index ? "descending" : "ascending");
				}
				if (explicit_index)
					isqlGlob.printf(" %s", RELC1.RDB$INDEX_NAME);

				isqlGlob.prints(NEWLINE);
			END_FOR
			ON_ERROR
				ISQL_errmsg (fbStatus);
				return ps_ERR;
			END_ERROR
		}

	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR

	FOR R_C IN RDB$RELATION_CONSTRAINTS CROSS
		C_C IN RDB$CHECK_CONSTRAINTS
		WITH R_C.RDB$RELATION_NAME   EQ relation_name
		AND R_C.RDB$CONSTRAINT_TYPE EQ 'NOT NULL'
		AND R_C.RDB$CONSTRAINT_NAME EQ C_C.RDB$CONSTRAINT_NAME

		if (!fb_utils::implicit_integrity(R_C.RDB$CONSTRAINT_NAME))
		{
			fb_utils::exact_name(C_C.RDB$TRIGGER_NAME);
			fb_utils::exact_name(R_C.RDB$CONSTRAINT_NAME);
			isqlGlob.printf("CONSTRAINT %s:%s", R_C.RDB$CONSTRAINT_NAME, NEWLINE);
			isqlGlob.printf("  Not Null Column (%s)%s", C_C.RDB$TRIGGER_NAME, NEWLINE);
		}
	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR;

	// Do check constraints

	show_check(relation_name);

	// Do triggers

	show_trigger(relation_name, false, false);

	// Do publications

	show_pub_table(relation_name);

	if (first)
		return (OBJECT_NOT_FOUND);
	return SKIP;
}


static processing_state show_trigger(const SCHAR* object, bool show_source, bool isTriggerName)
{
/**************************************
 *
 *	s h o w _ t r i g g e r
 *
 **************************************
 *
 * Functional description
 *	Show triggers in general or for the named object or trigger
 *
 **************************************/
	bool first = true;

	// Show all triggers
	if (!*object)
	{
		bool has_dbtrig = false;

		if (ENCODE_ODS(isqlGlob.major_ods, isqlGlob.minor_ods) >= ODS_11_1)
		{
			FOR TRG IN RDB$TRIGGERS
				WITH (TRG.RDB$SYSTEM_FLAG EQ 0 OR TRG.RDB$SYSTEM_FLAG MISSING) AND
					 TRG.RDB$RELATION_NAME MISSING
				SORTED BY TRG.RDB$TRIGGER_NAME
			{
				if (!has_dbtrig)
					has_dbtrig = true;

				fb_utils::exact_name(TRG.RDB$TRIGGER_NAME);

				isqlGlob.printf("%s", TRG.RDB$TRIGGER_NAME);

				if (TRG.RDB$SYSTEM_FLAG == 1)
					isqlGlob.printf("; System");

				if (!(TRG.RDB$VALID_BLR.NULL || TRG.RDB$VALID_BLR))
					isqlGlob.printf("; Invalid");

				isqlGlob.printf("%s", NEWLINE);
			}
			END_FOR
			ON_ERROR
				ISQL_errmsg(fbStatus);
				return ps_ERR;
			END_ERROR;
		}

		FOR TRG IN RDB$TRIGGERS CROSS REL IN RDB$RELATIONS
			//WITH (REL.RDB$SYSTEM_FLAG NE 1 OR REL.RDB$SYSTEM_FLAG MISSING) AND
			//NOT (ANY CHK IN RDB$CHECK_CONSTRAINTS WITH
			//	 TRG.RDB$TRIGGER_NAME EQ CHK.RDB$TRIGGER_NAME)
			WITH (TRG.RDB$SYSTEM_FLAG EQ 0 OR TRG.RDB$SYSTEM_FLAG MISSING) AND
			TRG.RDB$RELATION_NAME = REL.RDB$RELATION_NAME
			SORTED BY TRG.RDB$RELATION_NAME, TRG.RDB$TRIGGER_NAME
		{
			if (first)
			{
				if (has_dbtrig)
					isqlGlob.printf("%s", NEWLINE);

				first = false;
			}

			fb_utils::exact_name(TRG.RDB$TRIGGER_NAME);
			fb_utils::exact_name(TRG.RDB$RELATION_NAME);

			isqlGlob.printf("%s", TRG.RDB$TRIGGER_NAME);

			if (!TRG.RDB$RELATION_NAME.NULL)
				isqlGlob.printf("; Table: %s", TRG.RDB$RELATION_NAME);

			if (TRG.RDB$SYSTEM_FLAG == 1)
				isqlGlob.printf("; System");

			if (!(TRG.RDB$VALID_BLR.NULL || TRG.RDB$VALID_BLR))
				isqlGlob.printf("; Invalid");

			isqlGlob.printf("%s", NEWLINE);
		}
		END_FOR
		ON_ERROR
			ISQL_errmsg(fbStatus);
			return ps_ERR;
		END_ERROR;

		if (first && !has_dbtrig)
			return OBJECT_NOT_FOUND;

		return (SKIP);
	}

	// Show triggers for the named object
	// and avoid check constraints
	BASED_ON RDB$TRIGGERS.RDB$TRIGGER_NAME triggerName;
	BASED_ON RDB$TRIGGERS.RDB$RELATION_NAME relationName;

	if (isTriggerName)
	{
		sprintf(triggerName, "%s", object);
		relationName[0] = '\0';
	}
	else
	{
		sprintf(relationName, "%s", object);
		triggerName[0] = '\0';
	}

	FOR TRG IN RDB$TRIGGERS WITH
		(TRG.RDB$RELATION_NAME EQ relationName OR
			TRG.RDB$TRIGGER_NAME EQ triggerName) AND
		(TRG.RDB$SYSTEM_FLAG EQ 0 OR TRG.RDB$SYSTEM_FLAG MISSING)
		SORTED BY TRG.RDB$RELATION_NAME, TRG.RDB$TRIGGER_TYPE,
		TRG.RDB$TRIGGER_SEQUENCE, TRG.RDB$TRIGGER_NAME

		//bool skip = false;
		// Skip triggers for check constraints
		//FOR FIRST 1 CHK IN RDB$CHECK_CONSTRAINTS WITH
		//	TRG.RDB$TRIGGER_NAME EQ CHK.RDB$TRIGGER_NAME
		//	skip = true;
		//END_FOR
		//ON_ERROR
		//	ISQL_errmsg (fbStatus);
		//	return ps_ERR;
		//END_ERROR;

		//if (skip)
		//	continue;
		fb_utils::exact_name(TRG.RDB$TRIGGER_NAME);

		if (first)
		{
			if (!TRG.RDB$RELATION_NAME.NULL)
			{
				fb_utils::exact_name(TRG.RDB$RELATION_NAME);

				isqlGlob.printf("%sTriggers on Table %s:%s", NEWLINE, TRG.RDB$RELATION_NAME, NEWLINE);
			}

			first = false;
		}

		const char* ss = TRG.RDB$SQL_SECURITY.NULL ? "" :
							(TRG.RDB$SQL_SECURITY ? ", SQL SECURITY DEFINER" : ", SQL SECURITY INVOKER");

		isqlGlob.printf("%s, Sequence: %d, Type: %s, %s%s%s",
				 TRG.RDB$TRIGGER_NAME,
				 TRG.RDB$TRIGGER_SEQUENCE,
				 SHOW_trigger_action(TRG.RDB$TRIGGER_TYPE).c_str(),
				 (TRG.RDB$TRIGGER_INACTIVE ? "Inactive" : "Active"),
				 ss,
				 NEWLINE);

		if (show_source)
		{
			if (!TRG.RDB$ENTRYPOINT.NULL)
			{
				fb_utils::exact_name(TRG.RDB$ENTRYPOINT);
				isqlGlob.printf("External name: %s%s", TRG.RDB$ENTRYPOINT, NEWLINE);
			}

			if (!TRG.RDB$ENGINE_NAME.NULL)
			{
				fb_utils::exact_name(TRG.RDB$ENGINE_NAME);
				isqlGlob.printf("Engine: %s%s", TRG.RDB$ENGINE_NAME, NEWLINE);
			}

			// Use print_blob to print the blob

			if (!TRG.RDB$TRIGGER_SOURCE.NULL)
			{
				isqlGlob.printf("Trigger text:%s", NEWLINE);
				isqlGlob.printf("=============================================================================%s", NEWLINE);
				SHOW_print_metadata_text_blob (isqlGlob.Out, &TRG.RDB$TRIGGER_SOURCE);
				isqlGlob.printf("%s=============================================================================%s", NEWLINE, NEWLINE);
			}
		}

	END_FOR
	ON_ERROR
		ISQL_errmsg(fbStatus);
		return ps_ERR;
	END_ERROR;
	if (first)
		return OBJECT_NOT_FOUND;
	return SKIP;
}

static processing_state show_users12()
{
/**************************************
 *
 *	s h o w _ u s e r s 1 2
 *
 **************************************
 *
 * Functional description
 *	Show users logged in and/or defined for the database.
 *
 **************************************/

	const char* getusers = "select "
		"case when coalesce(MON$USER, SEC$USER_NAME) = current_user then '#' "
			 "when SEC$USER_NAME is distinct from null then ' ' else '-' end, "
		"coalesce(MON$USER, SEC$USER_NAME), count(MON$USER) "
		"from mon$attachments m full join sec$users u on m.MON$USER = u.SEC$USER_NAME "
		"where coalesce(MON$SYSTEM_FLAG, 0) = 0 "
		"group by MON$USER, SEC$USER_NAME order by coalesce(MON$USER, SEC$USER_NAME)";

	Firebird::RefPtr<Firebird::IMetadataBuilder>
		mb(Firebird::REF_NO_INCR, fbMaster->getMetadataBuilder(fbStatus, 3));
	if (ISQL_errmsg (fbStatus))
		return ps_ERR;

	mb->setType(fbStatus, 0, SQL_TEXT);
	if (ISQL_errmsg (fbStatus))
		return ps_ERR;
	mb->setLength(fbStatus, 0, 1);
	if (ISQL_errmsg (fbStatus))
		return ps_ERR;

	mb->setType(fbStatus, 1, SQL_VARYING);
	if (ISQL_errmsg (fbStatus))
		return ps_ERR;
	mb->setLength(fbStatus, 1, MAX_SQL_IDENTIFIER_SIZE);
	if (ISQL_errmsg (fbStatus))
		return ps_ERR;

	mb->setType(fbStatus, 2, SQL_LONG);
	if (ISQL_errmsg (fbStatus))
		return ps_ERR;

	Firebird::RefPtr<Firebird::IMessageMetadata>
		outMetadata(Firebird::REF_NO_INCR, mb->getMetadata(fbStatus));
	if (ISQL_errmsg (fbStatus))
		return ps_ERR;

	Firebird::AlignedBuffer<MAX_SQL_IDENTIFIER_SIZE + 32> outBuffer;
	fb_assert(outMetadata->getMessageLength(fbStatus) <= outBuffer.size());

	char* mark = (char*) &outBuffer[outMetadata->getOffset(fbStatus, 0)];
	if (ISQL_errmsg (fbStatus))
		return ps_ERR;
	vary* username = (vary*) &outBuffer[outMetadata->getOffset(fbStatus, 1)];
	if (ISQL_errmsg (fbStatus))
		return ps_ERR;
	int* cnt = (int*) &outBuffer[outMetadata->getOffset(fbStatus, 2)];
	if (ISQL_errmsg (fbStatus))
		return ps_ERR;

	Firebird::IResultSet* rs = DB->openCursor(fbStatus, fbTrans, 0, getusers, isqlGlob.SQL_dialect,
		NULL, NULL, outMetadata, NULL, 0);
	if (ISQL_errmsg (fbStatus))
		return ps_ERR;

	processing_state rc = OBJECT_NOT_FOUND;

	while (rs->fetchNext(fbStatus, outBuffer) == Firebird::IStatus::RESULT_OK)
	{
		if (rc == OBJECT_NOT_FOUND)
		{
			// First time in the loop, print title.
			TEXT msg[MSG_LENGTH]; // When messages can be translated.
			IUTILS_msg_get(USERS_IN_DB, msg);
			isqlGlob.printf("%s\n", msg);
			rc = SKIP; // We found at least one user.
		}

		isqlGlob.printf("%3d %c%.*s", *cnt, *mark, username->vary_length, username->vary_string);
		isqlGlob.printf("\n");
	}
	if (ISQL_errmsg (fbStatus))
		rc = ps_ERR;

	rs->release();

	return rc;
}

static processing_state show_users()
{
/**************************************
 *
 *	s h o w _ u s e r s
 *
 **************************************
 *
 * Functional description
 *	Show users logged in the database (not users defined for this database).
 *
 **************************************/

	if (isqlGlob.major_ods >= ODS_VERSION12)
		return show_users12();

	const UCHAR user_items[] =
	{
		isc_info_user_names,
		isc_info_end
	};

	TEXT msg[MSG_LENGTH]; // When messages can be translated.

	Firebird::RefPtr<Firebird::IMetadataBuilder>
		mb(Firebird::REF_NO_INCR, fbMaster->getMetadataBuilder(fbStatus, 1));
	if (ISQL_errmsg (fbStatus))
		return ps_ERR;
	mb->setType(fbStatus, 0, SQL_VARYING);
	if (ISQL_errmsg (fbStatus))
		return ps_ERR;
	mb->setLength(fbStatus, 0, MAX_SQL_IDENTIFIER_SIZE);
	if (ISQL_errmsg (fbStatus))
		return ps_ERR;

	Firebird::RefPtr<Firebird::IMessageMetadata>
		outMetadata(Firebird::REF_NO_INCR, mb->getMetadata(fbStatus));
	if (ISQL_errmsg (fbStatus))
		return ps_ERR;

	Firebird::AlignedBuffer<MAX_SQL_IDENTIFIER_SIZE + 32> outBuffer;
	fb_assert(outMetadata->getMessageLength(fbStatus) <= outBuffer.size());
	unsigned off = outMetadata->getOffset(fbStatus, 0);
	if (ISQL_errmsg (fbStatus))
		return ps_ERR;
	vary* my_user = (vary*) &outBuffer[off];

	const char* getuser = isqlGlob.major_ods < ODS_VERSION10 ?
	    "select user from rdb$database" : "select current_user from rdb$database";
	DB->execute(fbStatus, fbTrans, 0, getuser, isqlGlob.SQL_dialect,
		NULL, NULL, outMetadata, outBuffer);
	if (ISQL_errmsg (fbStatus))
		return OBJECT_NOT_FOUND;
	my_user->vary_string[my_user->vary_length] = 0; // Just for the debugger.

	UCHAR buffer[BUFFER_LENGTH512];
	DB->getInfo(fbStatus, sizeof(user_items), user_items, sizeof(buffer), buffer);
	if (ISQL_errmsg(fbStatus))
		return ps_ERR;

	processing_state rc = OBJECT_NOT_FOUND;

	for (Firebird::ClumpletReader p(Firebird::ClumpletReader::InfoResponse, buffer, sizeof(buffer)); !p.isEof(); p.moveNext())
	{
		switch (p.getClumpTag())
		{
		case isc_info_user_names:
			{
				if (rc == OBJECT_NOT_FOUND)
				{
					// First time in the loop, print title.
					IUTILS_msg_get(USERS_IN_DB, msg);
					isqlGlob.printf("%s\n", msg);
					rc = SKIP; // We found at least one user.
				}

				unsigned len = p.getBytes()[0];
				fb_assert(len == p.getClumpLength() - 1);
				const UCHAR* uname = p.getBytes() + 1;
				// Let's mark all attachments with our same user with a # prefix.
				bool same(len == my_user->vary_length && !memcmp(my_user->vary_string, uname, len));
				isqlGlob.printf("%c %.*s", same ? '#' : ' ', len, uname);
				isqlGlob.printf("\n");
			}
			break;

		case isc_info_truncated:
			isqlGlob.printf("\n");

			IUTILS_msg_get(OUTPUT_TRUNCATED, msg);
			isqlGlob.printf("%s\n", msg);
			return rc; // If we got some items, we are (partially) successful.
		}
	}

	return rc;
}

static processing_state show_wireStats()
{
	if (!DB)
	{
		isqlGlob.printf("No database connection.\n");
		return SKIP;
	}

	IsqlWireStats stats(DB);
	if (!stats.print(true))
		return ps_ERR;

	return SKIP;
}
